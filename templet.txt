************************************************************************
Aho-Corasick automaton
struct node
{
	node *next[26];
	node *fail;
	int sum;
};
node *root,*newnode,*q[N];
int cnt,head,tail;
void insert(char *s)
{
	node *p=root;
	for(int i=0;s[i];i++){
		int x=s[i]-'a';
		if(p->next[x]==NULL){
			newnode=(struct node*)malloc(sizeof(struct node));
			for(int j=0;j<26;j++)newnode->next[j]=NULL;
			newnode->sum=0;newnode->fail=NULL;
			p->next[x]=newnode;
		}
		p=p->next[x];
	}
	p->sum++;
}
void build_fail()
{
	head=0;tail=1;q[head]=root;
	node *p,*temp;
	while(head<tail){
		temp=q[head++];
		for(int i=0;i<26;i++){
			if(temp->next[i]){
				if(temp==root) temp->next[i]->fail=root;
				else{
					p=temp->fail;
					while(p){
						if(p->next[i]){temp->next[i]->fail=p->next[i];break;}
						p=p->fail;
					}
					if(p==NULL)temp->next[i]->fail=root;
				}
				q[tail++]=temp->next[i];
			}
		}
	}
}
void ac_automation(char *ch)
{
	node *p=root;
	for(int i=0;ch[i];i++){
		int x=ch[i]-'a';
		while(!p->next[x]&&p!=root)p=p->fail;
		p=p->next[x];
		if(!p)p=root;
		node *temp=p;
		while(temp!=root){
			if(temp->sum>=0){
				cnt+=temp->sum;
				temp->sum=-1;
			}
			else break;
			temp=temp->fail;
		}
	}
}
************************************************************************
Suffix Automaton
struct SAM{
	int ch[N][26],tot,dis[N],fa[N],root,last,sg[N];
	char a[N];
	bool init(){
		memset(ch,0,sizeof(ch));memset(dis,0,sizeof(dis));
		memset(fa,0,sizeof(fa));memset(sg,-1,sizeof(sg));
		tot=0;root=last=++tot;return true;
	}
	void build(){
		int n=strlen(a+1);
		for(int i=1;i<=n;i++)add(i);
	}
	void add(int pos){
		int x=a[pos]-'a',p=last,np=++tot;
		last=np,dis[np]=pos;
		for(;p&&!ch[p][x];p=fa[p])ch[p][x]=np;
		if(!p)fa[np]=root;
		else{
			int q=ch[p][x];
			if(dis[q]==dis[p]+1)fa[np]=q;
			else{
				int nq=++tot;
				dis[nq]=dis[p]+1;
				memcpy(ch[nq],ch[q],sizeof(ch[q]));
				fa[nq]=fa[q],fa[np]=fa[q]=nq;
				for(;ch[p][x]==q;p=fa[p])ch[p][x]=nq;
			}
		}
	}
	//Longest Commom Substring
	int ask(char b[]){
		int ans=0,len=0,p=root,m=strlen(b+1);
		for(int i=1;i<=m;i++){
			int x=b[i]-'a';
			if(ch[p][x])len++,p=ch[p][x];
			else{
				while(p&&!ch[p][x])p=fa[p];
				if(!p)p=root,len=0;
				else len=dis[p]+1,p=ch[p][x];
			}ans=max(ans,len);
		}
		return ans;
	}
	//sg function
	void getsg(int p){
		if(sg[p]!=-1)return ;
		bool vis[31];//can change 31
		for(int i=0;i<=30;i++)vis[i]=false;
		for(int i=0;i<26;i++){ 
			if(ch[p][i]){
				if(sg[ch[p][i]]==-1)getsg(ch[p][i]);
				vis[sg[ch[p][i]]]=1;
			}
		}
		for(int i=0;i<=30;i++) if(!vis[i]){sg[p]=i;return ;}
	}
	int calsg(char b[]){
		int m=strlen(b+1),p=1;
		for(int i=1;i<=m;i++)p=ch[p][b[i]-'a'];
		return sg[p];
	}
}T;
************************************************************************
Linear basis
vector<int>base;
void add(int x){for(auto &t:base)x=min(x,x^t);if(x){for(auto &t:base)t=min(t,t^x);base.pb(x);}}
int query(int x){for(auto &t:base)x=min(x,x^t);return x;}//ask min
************************************************************************
Mobius function
void init_mus()
{
	cnt=0;memset(vis,0,sizeof(vis));
	mus[1]=1;
	for(int i=2;i<N;i++){
		if(!vis[i]){prime[cnt++]=i;mus[i]=-1;}
		for(int j=0;j<cnt&&i*prime[j]<N;j++){
			vis[i*prime[j]]=1;
			if(i%prime[j]==0){mus[i*prime[j]]=0;break;}
			else mus[i*prime[j]]=-mus[i];
		}
	}
}
************************************************************************
Euler function
void init_euler()
{
	memset(prime,0,sizeof(p));
	memset(phi,0,sizeof(phi));
	memset(vis,0,sizeof(vis));
	for(int i=2;i<N;i++){
		if(!vis[i]){prime[++prime[0]]=i;phi[i]=i-1;}
		for(int j=1;j<=prime[0];j++){
			if(i*prime[j]>=N)break;
			vis[i*prime[j]]=true;
			if(!(i%prime[j])){phi[i*prime[j]]=phi[i]*prime[j];break;}
			phi[i*prime[j]]=phi[i]*(prime[j]-1);
		}
	}phi[1]=1;
}
************************************************************************
x*(x+1)/2 <==> mult(x,x+1,p)*modexp(2,p-2,p)%p
inline ll mult(ll a,ll b,ll p)
{
	ll ans=0;
	while(b){if(b&1)ans=(ans+a)%p;b>>=1;a=(a+a)%p;}
	return ans;
}
************************************************************************
IO
namespace IO {
    const int MT = 10 * 1024 * 1024;  /// 10MB 请注意输入数据的大小！！！
    char IO_BUF[MT];
    int IO_PTR, IO_SZ;
    /// 要记得把这一行添加到main函数第一行！！！
    void begin() {
        IO_PTR = 0;
        IO_SZ = fread (IO_BUF, 1, MT, stdin);
    }
    template<typename T>
    inline bool scan_d (T & t) {
        while (IO_PTR < IO_SZ && IO_BUF[IO_PTR] != '-' && (IO_BUF[IO_PTR] < '0' || IO_BUF[IO_PTR] > '9'))
            IO_PTR ++;
        if (IO_PTR >= IO_SZ) return false;
        bool sgn = false;
        if (IO_BUF[IO_PTR] == '-') sgn = true, IO_PTR ++;
        for (t = 0; IO_PTR < IO_SZ && '0' <= IO_BUF[IO_PTR] && IO_BUF[IO_PTR] <= '9'; IO_PTR ++)
            t = t * 10 + IO_BUF[IO_PTR] - '0';
        if (sgn) t = -t;
        return true;
    }
    inline bool scan_s (char s[]) {
        while (IO_PTR < IO_SZ && (IO_BUF[IO_PTR] == ' ' || IO_BUF[IO_PTR] == '\n') ) IO_PTR ++;
        if (IO_PTR >= IO_SZ) return false;
        int len = 0;
        while (IO_PTR < IO_SZ && IO_BUF[IO_PTR] != ' ' && IO_BUF[IO_PTR] != '\n')
            s[len ++] = IO_BUF[IO_PTR], IO_PTR ++;
        s[len] = '\0';
        return true;
    }
    template<typename T>
    void print(T x) {
        static char s[33], *s1; s1 = s;
        if (!x) *s1++ = '0';
        if (x < 0) putchar('-'), x = -x;
        while(x) *s1++ = (x % 10 + '0'), x /= 10;
        while(s1-- != s) putchar(*s1);
    }
    template<typename T>
    void println(T x) {
        print(x); putchar('\n');
    }
};
************************************************************************