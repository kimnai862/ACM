
## 博弈论

### 打表

``` 
//f[]：可以取走的石子个数
//sg[]:0~n的SG函数值
//hash[]:mex{}
int f[N],sg[N],hash[N];     
void getSG(int n)
{
    int i,j;
    memset(sg,0,sizeof(sg));
    for(i=1;i<=n;i++)
    {
        memset(hash,0,sizeof(hash));
        for(j=1;f[j]<=i;j++)
            hash[sg[i-f[j]]]=1;
        for(j=0;j<=n;j++)    //求mes{}中未出现的最小的非负整数
        {
            if(hash[j]==0)
            {
                sg[i]=j;
                break;
            }
        }
    }
}

```

### DFS

```
//注意 S数组要按从小到大排序 SG函数要初始化为-1 对于每个集合只需初始化1遍
//n是集合s的大小 S[i]是定义的特殊取法规则的数组
int s[110],sg[10010],n;
int SG_dfs(int x)
{
    int i;
    if(sg[x]!=-1)
        return sg[x];
    bool vis[110];
    memset(vis,0,sizeof(vis));
    for(i=0;i<n;i++)
    {
        if(x>=s[i])
        {
            SG_dfs(x-s[i]);
            vis[sg[x-s[i]]]=1;
        }
    }
    int e;
    for(i=0;;i++)
        if(!vis[i])
        {
            e=i;
            break;
        }
    return sg[x]=e;
}

```



### 巴什博奕 

只有一堆n个物品，两个人轮流从中取物，规定每次最少取一个，最多取m个，最后取光者为胜

答案：先手必败 n%(m+1)=0

### 威佐夫博弈

有两堆各若干的物品，两人轮流从其中一堆取至少一件物品，至多不限，或从两堆中同时取相同件物品，规定最后取完者胜利。

答案：若两堆物品的初始值为（x，y），且x<y，则另z=y-x；记w=（int）[（（sqrt（5）+1）/2）\*z  ]；若w=x，则先手必败，否则先手必胜。

### 斐波那契博弈

有一堆物品，两人轮流取物品，先手最少取一个，至多无上限，但不能把物品取完，之后每次取的物品数不能超过上一次取的物品数的二倍且至少为一件，取走最后一件物品的人获胜。

答案：先手胜当且仅当n不是斐波那契数

### 取走-分割游戏

Lasker’s Nim游戏：每一轮允许两种操作之一。（1）从一堆石子中取走任意多个（2）将一堆数量不少于2的石子分成都不为空的两堆。 

答案：对于所有的k>=0，有g(4k+1)=4k+1；g(4k+2)=4k+2；g(4k+3)=4k+4；g(4k+4)=4k+3。 

### POJ 1740

有N堆石子，两人轮流进行操作，每一次为“操作者指定一堆石子，先从中扔掉一部分（至少一颗，可以全部扔掉），然后可以将该堆剩下的石子中的任意多颗任意移到其他未取完的堆中”，操作者无法完成操作时为负。 

答案：必败态的条件为“堆数为偶数（不妨设为2N），并且可以分为两两相等的N对” 

### 阶梯博弈

从左到右有一排石子，给出石子所在的位置。规定每个石子只能向左移动，且不能跨过前面的石子。最左边的石子最多只能移动到1位置。每次选择一个石子按规则向左移动，问先手是否能赢。 

答案：我们把棋子按位置升序排列后，从后往前把他们两两绑定成一对。如果总个数是奇数，就把最前面一个和边界（位置为0）绑定。 在同一对棋子中，如果对手移动前一个，你总能对后一个移动相同的步数，所以一对棋子的前一个和前一对棋子的后一个之间有多少个空位置对最终的结果是没有影响的。 于是我们只需要考虑同一对的两	个棋子之间有多少空位。 这样一来就成了N堆取石子游戏了. 

### 翻硬币游戏

 N 枚硬币排成一排。有的正面朝上。有的反面朝上。我们从左開始对硬币按1 到N 编号。 游戏者依据某些约束翻硬币，但他所翻动的硬币中，最右边那个硬币的必须是从正面翻到反面。 谁不能翻谁输。 

局面的 SG 值为局面中每个正面朝上的棋子单一存在时的 SG 值的异或和。 

SG(HHTHTTHT)=SG(H)^SG(TH)^SG(TTTH)^SG(TTTTTTH)  

**约束条件1：**每次仅仅能翻一个硬币。 

​	有奇数个正面硬币。局面的SG值==1，先手必胜，有偶数个正面硬币，局面的SG值==0。先手必败。 

**约束条件2：**每次能翻转一个或两个硬币。 不用连续

​	每一个硬币的SG值为它的编号。初始编号为0。与NIM游戏是一样的。 (只有一个正面硬币且在0位置特判)

**约束条件3：**每次必须连续翻转k个硬币。 

​	我们计算的是个数为N的硬币中，当中最后一个硬币为正面朝上,的sg值。 

​	sg的形式为000…01 000…01，当中一小段0的个数为k-1。 

**约束条件4：**每次翻动一个硬币后。必须翻动其左側近期三个硬币中的一个，即翻动第x个硬币后。必须选择x-1。								x-2，x-3中的当中一个硬币进行翻动，除非x是小于等于3的。（Subtraction Games） 

​	考虑单一硬币，这个与每次最多仅仅能取3个石子的取石子游戏的SG分布一样 ，

​	1，2，3，4，5（1，2，3，0，1）

**约束条件5：**每次必须翻动两个硬币，并且这两个硬币的距离要在可行集S={1,2,3}中。硬币序号从0開始。(Twins游戏) 

​	与约束条件4一样，0，1，2，3，4，5，（0，1，2，3，0，1）

**约束条件6：**每次能够翻动一个、二个或三个硬币。 （Mock Turtles游戏） 

​	0  1  2  3  4   5    6   7    8     9  10  11  12  13  14 （1  2  4  7  8  11 13 14  16  19  21  22  25  26  28 ）

​	sg值为2x或者2x+1。我们称一个非负整数为odious，当且仅当该数的二进制形式的1出现的次数是奇数，否则称作evil。所以1，2。4，7是odious由于它们的二进制形式是1,10,100,111.而0,3,5,6是evil，由于它们的二进制形式是0,11,101,110。上面 sg值都是odious数。所以当2x为odious时，sg值是2x，当2x是evil时。sg值是2x+1. 

**约束条件7：**每次能够连续翻动随意个硬币，至少翻一个。 （Ruler游戏） 

​	1  2  3  4  5  6  7  8  9  10  11  12  13  14  15   16 （1  2  1  4  1  2  1  8  1    2    1     4    1    2     1   16 ）

​	sg值为x的因数其中2的能达到的最大次幂。比方14=2*7，最大1次幂。即2；16=2*2*2*2。最大4次幂，即16。 

**约束条件8：**每次必须翻转4个对称的硬币，最左与最右的硬币都必须是从正翻到反。（開始的时候两端都是正面）（Grunt游戏） 

​	这是Grundy游戏的变种，初始编号从0開始。 当首正硬币位置为0,1,2时是terminal局面，即 终结局面，sg值都是0。当首正硬币位置n大于等于3的时候的局面能够通过翻0,x,n-x,n四个位置得到(当中x<n/2可保证胜利)。

这就像是把一堆石子分成两堆不同大小石子的游戏，也就是Grundy游戏。

### Grundy游戏

一开始有大小为n的一个堆，每次可以将大小大于2的堆拆成两个大小不同的堆,

可以使用[Sprague-Grundy定理](https://en.wikipedia.org/wiki/Sprague%E2%80%93Grundy_theorem)分析游戏。这需要将游戏中的堆大小映射到等效的[nim堆大小](https://en.wikipedia.org/wiki/Nim)。 

Heap Size:                    0  1  2  3  4  5  6  7  8  9 10 11 12 13 14 15 16 17 18 19 20 

Equivalent NIM heap: 0  0  0  1  0  2  1  0  2  1  0    2    1   3   2   1   3   2   4   3   0

目前没有一个公式可以计算sg值

```
#include <algorithm>
#include <array>
#include <iostream>
int main() {
    constexpr int bound = 10000;
    std::array<int, bound+1> gnumbers;
    std::array<bool, bound/2+1> excluded;
    for (int i = 0; i <= bound; ++i) {
        auto e_begin = excluded.begin();
        auto e_end = e_begin + i/2;
        std::fill(e_begin, e_end, false);
        for (int j = 1; j < (i+1)/2; ++j) {
            int const k = i - j;
            excluded[gnumbers[j] ^ gnumbers[k]] = true;
        }
        gnumbers[i] = std::find(e_begin, e_end, false) - e_begin;
    }
    for (int i = 0; i <= bound; ++i)
        std::cout << i << ' ' << gnumbers[i] << '\n';
}
```

