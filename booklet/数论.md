## 数论

### 区间素数筛

```c++
const int MAXN = 1e6+1e3;   //待筛的区间[L,R]长度
const int N = 50001;//保证大于(2^31-1)的算数平方根
bool prime[MAXN];
bool seive[N];
typedef long long ll;
int len;
void init()
{
        for(int i=2;i<N;i++) seive[i]=1;
        for(int i=2;i*i<N;i++)  //预处理
            if(seive[i])
                for(int j=2*i;j<N;j+=i)
                    seive[j]=false;
}
void seg_seive(ll L,ll R)   //区间筛法
{
    len=R-L+1;
    for(int i=0;i<len;i++) prime[i]=1;
    if(1-L>=0) prime[1-L]=0;   //易错因为1不是素数也不是合数，这也是区间筛的一个易错bug
    for(ll i=2; i*i<=R ;i++)
    {
        if(seive[i])
        {
            for(ll j=max((ll)2,(L-1+i)/i)*i;j<=R;j+=i)  //第二个易错点，j必须从大于1，因为L可能小于i，但是seive[i]是素数。
                prime[j-L]=false;
        }
    }
}
```

### 大质数判定与大数分解

```
typedef long long LL;
LL ans;
LL modmul(LL a,LL b,LL mod)
{
    LL ret=0;
    for(;b;b>>=1,a=(a+a)%mod)
        if(b&1)ret=(ret+a)%mod;
    return ret;
}
LL qpow(LL x,LL u,LL mod)
{
    LL ret=1LL;
    for(;u;u>>=1,x=modmul(x,x,mod))
        if(u&1)ret=modmul(ret,x,mod);
    return ret;
}
LL gcd(LL a,LL b)
{
    return b?gcd(b,a%b):a;
}
LL Pollard_Rho(LL n,LL c)
{
    LL i=1,j=2,x=rand()%(n-1)+1,y=x;
    while(1)
    {
        i++;
        x=(modmul(x,x,n)+c)%n;
        LL p=gcd((y-x+n)%n,n);
        if(p!=1&&p!=n)return p;
        if(y==x)return n;
        if(i==j)
        {
            y=x;
            j<<=1;
        }
    }
}
bool Miller_Rabin(LL n)//判断是否为质数
{
    LL x,pre,u=n-1;
    int i,j,k=0;
    if(n==2||n==3||n==5||n==7||n==11)return 1;
    if(n==1||!(n%2)||!(n%3)||!(n%5)||!(n%7)||!(n%11))return 0;
    while(!(u&1))
    {
        k++;
        u>>=1;
    }
    srand((long long)12234336);
    for(i=1;i<=50;i++)
    {
        x=rand()%(n-2)+2;
        if(!(n%x))return 0;
        x=qpow(x,u,n);
        pre=x;
        for(j=1;j<=k;j++)
        {
            x=modmul(x,x,n);
            if(x==1&&pre!=1&&pre!=n-1)return 0;
            pre=x;
        }
        if(x!=1)return 0;
    }
    return 1;
}
LL prime[1000];int tot=0;
void find(LL n,LL c)//大数分解
{
    if(n==1)return;
    if(Miller_Rabin(n))
    {
        prime[tot++]=n;
        return;
    }
    LL x=n,k=c;
    while(x==n)x=Pollard_Rho(x,c--);
    find(n/x,k);
    find(x,k);
}
```



### 威尔逊定理

当且仅当p为质数，p可整除(p-1)!+1 ，即p|((p-1)!+1)

### 欧拉定理

若a,p为正整数且a,p互质 ，则$a^{φ(p)} \equiv 1 (mod p)$ 

### 扩展欧拉定理

 $gcd(a,p)=1时，a^b=a^{b \% \varphi(p)} (mod p)$

 $gcd(a,p)\not =1且b>=\varphi(p)时，a^b=a^{b \% \varphi(p)+\varphi(p)} (mod p)$

### 费马小定理

若p是质数，则$a^{p-1}\equiv 1 (mod p)$ 

### 费马大定理

 $a^n+b^n=c^n$ 当n>2时无整数解

### 中国剩余定理

```
//模数互质的情况，m[] 存模数，a[] 存模后的结果
ll m[N],a[N];
ll exgcd(ll a,ll b,ll &x,ll &y)
{
    if(b==0){x=1LL;y=0;return a;}
    ll r=exgcd(b,a%b,y,x);
    y-=a/b*x;
    return r;
}
ll china(ll n,ll *m,ll *a)
{
    ll M=1,d,y,x=0;
    for(int i=0;i<n;i++) M*=m[i];
    for(int i=0;i<n;i++){
        ll w=M/m[i];
        exgcd(m[i],w,d,y);
        x=(x+y*w*a[i])%M;
    }
    return (x+M)%M;
}
```

```
//模数不互质
struct China
{
    #define ll long long
    ll gcd(ll a,ll b){return b==0?a:gcd(b,a%b);}
    ll exgcd(ll a,ll b,ll &x,ll &y)
    {
        if(b==0){x=1LL;y=0;return a;}
        ll r=exgcd(b,a%b,y,x);
        y-=a/b*x;
        return r;
    }
    //a在模n乘法下的逆元，没有则返回-1
    ll inv(ll a,ll n)
    {
        ll x,y;
        ll t=exgcd(a,n,x,y);
        if(t!=1)return -1;
        return(x%n+n)%n;
    }
    //合并两个方程
    bool merge(ll a1,ll n1,ll a2,ll n2,ll& a3,ll& n3)
    {
        ll d=gcd(n1,n2);
        ll c=a2-a1;
        if(c%d)return false;
        c=(c%n2+n2)%n2;
        c/=d;n1/=d;n2/=d;
        c*=inv(n1,n2);
        c%=n2;c*=n1*d;
        c+=a1;
        n3=n1*n2*d;
        a3=(c%n3+n3)%n3;
        return true;
    }
    //求模线性方程组x=ai(mod ni) 可以不互质
    ll china(int len,ll* a,ll* n)
    {
        ll a1=a[0],n1=n[0];
        ll a2,n2;
        for(int i=1;i<len;i++){
            ll aa,nn;
            a2=a[i],n2=n[i];
            if(!merge(a1,n1,a2,n2,aa,nn))return -1;
            a1=aa;n1=nn;
        }
        return (a1%n1+n1)%n1;
    }
}china;
```





### 扩展欧几里得

```C++
ll exgcd(ll a,ll b,ll &x,ll &y)
{
    if(b==0){x=1LL;y=0;return a;}
    ll r=exgcd(b,a%b,y,x);
    y-=a/b*x;
    return r;
}
// by+(a-a/b*b)x = ax+b(y-a/b*x)
```

### 欧拉函数

```
//o(n)
void init_euler()
{
	memset(p1,0,sizeof(p1));
	memset(phi,0,sizeof(phi));
	memset(vis,0,sizeof(vis));
	for(int i=2;i<N;i++){
		if(!vis[i]){p1[++p1[0]]=i;phi[i]=i-1;}
		for(int j=1;j<=p1[0];j++){
			if(i*p1[j]>=N)break;
			vis[i*p1[j]]=true;
			if(!(i%p1[j])){phi[i*p1[j]]=phi[i]*p1[j];break;}
			phi[i*p1[j]]=phi[i]*(p1[j]-1);
		}
	}phi[1]=1;
	pre[0]=0;
	for(int i=1;i<N;i++)pre[i]=(pre[i-1]+phi[i])%p;
}
```

### 莫比乌斯函数

```c++
//o(n)
void init_mus()
{
	cnt=0;memset(vis,0,sizeof(vis));
	mus[1]=1;
	for(int i=2;i<N;i++){
		if(!vis[i]){prime[cnt++]=i;mus[i]=-1;}
		for(int j=0;j<cnt&&i*prime[j]<N;j++){
			vis[i*prime[j]]=1;
			if(i%prime[j]==0){mus[i*prime[j]]=0;break;}
			else mus[i*prime[j]]=-mus[i];
		}
	}
}
```

### 数论函数

​	积性函数：对于**任意互质的整数**a和b有性质$f(ab) = f(a)f(b)$的数论函数

​	完全积性函数：对任意整数a和b有性质$f(ab) = f(a)f(b)$的数论函数

​	约数函数：$\sigma_{k} = \sum_{d|n}^{}d^{k}$

​	原函数    ：$e = [n = 1]$

​	恒等函数：$I = 1$

​	单位函数：$ID = n$

​	幂函数    ：$ID^{k} = n^{k}$   $ID^{0} =  I$

​	狄利克雷卷积及其他：

​		卷积    ：$(a \times b)(n) = \sum_{d|n}a(d)b(\frac{n}{d})$

​		乘        ：$(a \cdot b) = a(n)b(n)$

​		加        ：$(a+b)(n) = a(n) + b(n)$

​		交换律：$a \times b = b \times a$

​		结合律：$(a \times b) \times c = a \times (b \times c)$

​		分配率：$(a + b) \times c = a \times c + b \times c$

​		单位元：$a \times e = a$

​		注意    ：$a \cdot e = e$

​		单位元的逆元(莫比乌斯函数)：$\mu \times I = e$

​		莫比乌斯反演：$f = g \times I \Leftrightarrow g = f \times \mu$

​		欧拉函数的卷积：$\phi \times I = ID \Leftrightarrow \phi = ID \times \mu$

​		恒等函数的卷积：$I \times I = \sigma_{0} \Leftrightarrow I = \sigma_{0} \times \mu$

​		幂函数的卷积：$ID^{k} \times I = \sigma_{k} \Leftrightarrow ID^{k} = \sigma_{k} \times \mu$

 		若：					 $b(x)b(\frac{n}{x}) = c(n)$

​		则：			 $(a \cdot b^{k}) \times b^{k} = \sum_{d|n}a(d)b(d)b(\frac{n}{d}) = (a \times I) \cdot c^{k}(n)$

​		另外一种表述：g在完全积性条件下：			

​					 $(f \cdot g) \times g = (f \times I) \cdot g$	

​		例子：由				 $ID^{k}(d)ID^{k}(\frac{n}{d}) = ID^{k}(n)$

​		可得：			 $(a \cdot ID^{k}) \times ID^{k} = (a \times I) \cdot ID^{k}$				 

​						 $(\phi \cdot ID^{k}) \times ID^{k} = (\phi \times I) \cdot ID^{k} = ID \cdot ID^{k} = ID^{k+1}$					 

​						 $(\mu \cdot ID^{k}) \times ID^{k} = (\mu \times I) \cdot ID^{k} = e \cdot ID^{k} = e$				 		

​						 $ID^{k} \times ID^{k} = (I \cdot ID^{k}) \times ID^{k} = (I \times I) \cdot ID^{k} = \sigma_{0} \cdot ID^{k}$

### 常用转换技巧

前n个正整数的约数之和：

​	  $\sum_{i=1}^{n}\sigma_{1}(i)=\sum_{i=1}^n\sum_{j=1}^{n}[j|i]*j=\sum_{i=1}^{n}i*\sum_{j=1}^{n}[i|j]=\sum_{i=1}^{n}i\ast \lfloor\frac{n}{i}\rfloor=\sum_{i=1}^{n}\frac{\lfloor\frac{n}{i}\rfloor\ast (\lfloor\frac{n}{i}\rfloor+1)}{2}$

前n个正整数的欧拉函数之和：

​	 $\varphi(n)=n-\sum_{d|n,d<n}\varphi(d)$ 	 $\phi(n)=\sum_{i=1}^{n}\varphi(i)$

​	 $\phi(n)=\sum_{i=1}^{n}\varphi(i)=\sum_{i=1}^{n}(i-\sum_{d|i,d<i}\varphi(d))=\frac{n*(n+1)}{2}-\sum_{i=2}^{n}\sum_{d|i,d<i}\varphi(d)$

​	   	  $=\frac{n*(n+1)}{2}-\sum_{i=2}^{n}\sum_{d=1}^{\lfloor\frac{n}{i}\rfloor}\varphi(d)=\frac{n*(n+1)}{2}-\sum_{i=2}^{n}\phi(\lfloor\frac{n}{i}\rfloor)$

   $\frac{n*(n+1)}{2}=\sum_{i}^{n}i=\sum_{i=1}^{n}\sum_{d|i}\varphi(d)=\sum_{\frac{i}{d}=1}^{n}\sum_{d=1}^{\lfloor\frac{n}{\frac{i}{d}}\rfloor}\varphi(d)=\sum_{i=1}^{n}\phi(\lfloor\frac{n}{i}\rfloor)$ 

前n个正整数的莫比乌斯函数之和（梅滕斯函数）：

 $1=\sum_{i=1}^{n}[i=1]=\sum_{i=1}^{n}\sum_{d|i}\mu(d)=\sum_{i=1}^{n}\sum_{d=1}^{\lfloor\frac{n}{i}\rfloor}\mu(d)=\sum_{i=1}^{n}M(\lfloor\frac{n}{i}\rfloor)$

 $M(n)=1-\sum_{i=2}^{n}M(\lfloor\frac{n}{i}\rfloor)$

 $\mu^2(d)=\sum_{k^2|d}\mu(k)$ :

证明：当d没有平方因子时 $\sum_{k^2|d}\mu(k)=1，\mu^2(d)=1$

​	   当d有平方因子x^2时 $\sum_{k^2|d}\mu(k)=\sum_{k^2|x^2}\mu(k)=\sum_{k|x}\mu(k)=0,\mu^2(d)=0$

前n个正整数的莫比乌斯函数平方之和：

​	 $S(n)=\sum_{i=1}^n\mu^2(i)=\sum_{d^2|i}\mu(d)=\sum_{i=1}^{n}\sum_{d=1}^{\sqrt{\lfloor\frac{n}{i}\rfloor}}\mu(d)=\sum_{i=1}^{\sqrt{n}}\mu(i)\lfloor \frac{n}{i^2} \rfloor$

前n个正整数的因数的莫比乌斯函数平方之和：

​	 $S(n)=\sum_{i=1}^{n}\sum_{d|i}\mu^2(d)=\sum_{i=1}^{n}\sum_{d|i}\sum_{k^2|d}\mu(k)=\sum_{i=1}^{n}\mu(i)\sum_{j=1}^{\frac{n}{i^2}}\lfloor\frac{n}{i^2j}\rfloor$

​	可发现i的取值范围可以缩小到$\sqrt{n}$ ，令$f(n)=\sum_{i=1}^{n}\lfloor\frac{n}{i}\rfloor$

​	则 $S(n)=\sum_{i=1}^{\sqrt{n}}\mu(i)f(\lfloor\frac{n}{i^2}\rfloor)$

小于等于n的两两数最小公倍数之和：

​	 $ans=\sum_{d=1}^{n}d\sum_{i=1}^{\lfloor\frac{n}{d}\rfloor}i^2\varphi(i)$

​	第二个求和式卷积即可求

小于等于n的两两数最大公约数之和：

​	 $ans=\sum_{i=1}^n\lfloor\frac{n}{i}\rfloor\ast \lfloor\frac{n}{i}\rfloor\ast \varphi(i)$

求lcm(a,b)+lcm(a+1,b)+...+lcm(b,b):

​	 $ans=\frac{b}{2}\sum_{T|b}(\frac{b}{T}+\lceil\frac{a}{T}\rceil)(\frac{b}{T}-\lceil\frac{a}{T}\rceil+1)\sum_{d|T}\mu(d)d$

​	最右边和式用积性函数性质算即可

求最小公倍数在某一区间的(x<=y)二元组数量：

​	区间[l,r]=[1,r]-[1,l-1]

​	 $G(n)=\sum_{i=1}^{n}\sum_{y=1}^{n}[\frac{xy}{gcd(x,y)}<=n]=\sum_{k=1}^{\sqrt{n}}\mu(k)H(\lfloor\frac{n}{k^2}\rfloor)$

​	 $H(n)=\sum_{a=1}^n\sum_{b=1}^{\lfloor\frac{n}{a}\rfloor}\sum_{c=1}^{\lfloor\frac{n}{ab}\rfloor}1$

​	 H(n)枚举前两项(a<=b)用组合数求即可

### FFT （快速傅里叶变换）

```c++
#define L(x) (1 << (x))
const double PI = acos(-1.0);
const int N = 2e5+5;
double ax[N],ay[N],bx[N],by[N];
int revv(int x, int bits)
{
    int ret=0;
    for(int i=0;i<bits;i++){ret<<=1;ret|=x&1;x>>=1;}
    return ret;
}
void fft(double * a, double * b, int n, bool rev)
{
    int bits=0;
    while((1<<bits)<n)++bits;
    for(int i=0;i<n;i++){
        int j=revv(i,bits);
        if(i<j)swap(a[i],a[j]),swap(b[i],b[j]);
    }
    for(int len=2;len<=n;len<<=1){
        int half=len>>1;
        double wmx=cos(2*PI/len),wmy=sin(2*PI/len);
        if(rev)wmy=-wmy;
        for(int i=0;i<n;i+=len){
            double wx=1,wy=0;
            for(int j=0;j<half;j++){
                double cx=a[i+j],cy=b[i+j];
                double dx=a[i+j+half],dy=b[i+j+half];
                double ex=dx*wx-dy*wy,ey=dx*wy+dy*wx;
                a[i+j]=cx+ex,b[i+j]=cy+ey;
                a[i+j+half]=cx-ex,b[i+j+half]=cy-ey;
                double wnx=wx*wmx-wy*wmy,wny=wx*wmy+wy*wmx;
                wx=wnx,wy=wny;
            }
        }
    }
    if(rev){for(int i=0;i<n;i++) a[i]/=n,b[i]/=n;}
}
int solve(int a[],int na,int b[],int nb,int ans[]) //两个数组求卷积,有时ans数组要开成long long
{
    int len=max(na,nb),ln;
    for(ln=0;L(ln)<len;++ln);
    len=L(++ln);
    for(int i=0;i<len;++i){
        if(i>=na)ax[i]=0,ay[i]=0;
        else ax[i]=a[i],ay[i]=0;
    }
    fft(ax,ay,len,0);
    for(int i=0;i<len;++i){
        if(i>=nb) bx[i]=0,by[i]=0;
        else bx[i]=b[i],by[i]=0;
    }
    fft(bx,by,len,0);
    for(int i=0;i<len;++i){
        double cx=ax[i]*bx[i]-ay[i]*by[i];
        double cy=ax[i]*by[i]+ay[i]*bx[i];
        ax[i]=cx,ay[i]=cy;
    }
    fft(ax,ay,len,1);
    for(int i=0;i<len;++i) ans[i]=(int)(ax[i]+0.5);
    return len;
}
```

### NTT （快速数论变换）

```C++
//选好素数
const int M = 22;
ll G=3,P=998244353,wn[M];//P=7*2^26+1，M=k-1
ll modexp(ll a,ll b,ll p){
    ll ans=1LL;a%=p;
    while(b){if(b&1)ans=ans*a%p;b>>=1;a=a*a%p;}
    return ans;
}
void getwn(){for(int i=0;i<M;i++) wn[i]=modexp(G,(P-1)/(1<<i),P);}//!!!记得用
void NTT(ll x[],int n,int rev) {
    int i,j,k,ds;ll w,u,v;
    for(i=1,j=n>>1,k=n>>1;i<n-1;i++,k=n>>1){
        if(i<j)swap(x[i],x[j]);
        while(j>=k){j-=k;k>>=1;}
        if(j<k)j+=k;
    }
    for(i=2,ds=1;i<=n;i<<=1,ds++)
        for(j=0;j<n;j+=i){
            w=1;
            for(k=j;k<j+i/2;k++){
                u=x[k]%P;v=w*x[k+i/2]%P;
                x[k]=(u+v)%P;
                x[k+i/2]=(u-v+P)%P;
                w=w*wn[ds]%P;
            }
        }
    if(rev==-1){
        for(i=1;i<n/2;i++) swap(x[i],x[n-i]);
        w=modexp(n,P-2,P);
        for(i=0;i<n;i++) x[i]=x[i]*w%P;
    }
}
int solve(ll a[],int lena,ll b[],int lenb) {//结果在a数组
    int n=1;
    while (n<lena+lenb) n<<=1;
    for(int i=lena;i<n;i++)a[i]=0;
    for(int i=lenb;i<n;i++)b[i]=0;
    NTT(a,n,1);NTT(b,n,1);
    for (int i=0;i<n;i++) a[i]=a[i]*b[i]%P;
    NTT(a,n,-1);
    return n;
} 
```

### 三模数NTT所需函数

```
inline ll mul(ll a,ll b,ll mod){
    a%=mod;b%=mod;
    return ((a*b-(ll)((ll)((long double)a/mod*b+1e-3)*mod))%mod+mod)%mod;
}
ll modexp(ll a,ll b,ll p)
{
    ll ans=1LL;a%=p;
    while(b){if(b&1)ans=ans*a%p;b>>=1;a=a*a%p;}
    return ans;
}
ll M[]={998244353,1004535809,469762049};
ll _M=(ll)M[0]*M[1];
ll m1=M[0],m2=M[1],m3=M[2];
ll inv1=modexp(m1%m2,m2-2,m2),inv2=modexp(m2%m1,m1-2,m1),inv12=modexp(_M%m3,m3-2,m3);
inline int CRT(int a1,int a2,int a3){//注意顺序
    ll A=(mul((ll)a1*m2%_M,inv2,_M)+mul((ll)a2*m1%_M,inv1,_M))%_M;
    ll k=((ll)a3+m3-A%m3)*inv12%m3;
    return (k*(_M%P)+A)%P;
}
```



### NTT 素数表

如果模数P 任意，取的模数必须超过n(P-1)^2 ，可以取多个模数（乘积>n(P-1)^2）做NTT。再用中国剩余定理合并,每次NTT转化为三个NTT再合并即可

```

r⋅2^k+1	r	k	g
3	1	1	2
5	1	2	2
17	1	4	3
97	3	5	5
193	3	6	5
257	1	8	3
7681	15	9	17
12289	3	12	11
40961	5	13	3
65537	1	16	3
786433	3	18	10
5767169	11	19	3
7340033	7	20	3
23068673	11	21	3
104857601	25	22	3
167772161	5	25	3
469762049	7	26	3
998244353	119	23	3
1004535809	479	21	3
2013265921	15	27	31
2281701377	17	27	3
3221225473	3	30	5
75161927681	35	31	3
77309411329	9	33	7
206158430209	3	36	22
2061584302081	15	37	7
2748779069441	5	39	3
6597069766657	3	41	5
39582418599937	9	42	5
79164837199873	9	43	5
263882790666241	15	44	7
1231453023109121	35	45	3
1337006139375617	19	46	3
3799912185593857	27	47	5
4222124650659841	15	48	19
7881299347898369	7	50	6
31525197391593473	7	52	3
180143985094819841	5	55	6
1945555039024054273	27	56	5
4179340454199820289	29	57	3
```

### 多项式开方、求逆、积分、求exp、求ln、求幂

多项式求逆： $B(x)=2G(x)-A(x)G^2(x) (mod x^n)$

多项式开方： $B(x)=\frac{A(x)+G^2(x)}{2G(x)} (mod x^n)$

​		 $G(x)=(1+ln(1+\frac{1}{exp(\lmoustache \frac{1}{\sqrt{F(x)}})}))^k$ 

```
//给定F(x) 求G'(x)
# include <bits/stdc++.h>
# define RG register
# define IL inline
# define Fill(a, b) memset(a, b, sizeof(a))
using namespace std;
typedef long long ll;

IL int Input(){
    RG int x = 0, z = 1; RG char c = getchar();
    for(; c < '0' || c > '9'; c = getchar()) z = c == '-' ? -1 : 1;
    for(; c >= '0' && c <= '9'; c = getchar()) x = (x << 1) + (x << 3) + (c ^ 48);
    return x * z;
}

const int maxn(8e5 + 5);
const int mod(998244353);
const int phi(998244352);
const int inv2(499122177);
const int g(3);

int a[maxn], b[maxn], c[maxn], d[maxn], r[maxn];

IL int Pow(RG ll x, RG ll y){
    RG ll ret = 1;x%=mod;
    for(; y; y >>= 1, x = x * x % mod)
        if(y & 1) ret = ret * x % mod;
    return ret;
}
IL void NTT(RG int *p, RG int m, RG int opt){
    RG int n = 1, l = 0;
    for(; n < m; n <<= 1) ++l;
    for(RG int i = 0; i < n; ++i) r[i] = (r[i >> 1] >> 1) | ((i & 1) << (l - 1));
    for(RG int i = 0; i < n; ++i) if(r[i] < i) swap(p[i], p[r[i]]);
    for(RG int i = 1; i < n; i <<= 1){
        RG int t = i << 1, wn = Pow(g, phi / t);
        if(opt == -1) wn = Pow(wn, mod - 2);
        for(RG int j = 0; j < n; j += t)
            for(RG int k = 0, w = 1; k < i; ++k, w = 1LL * w * wn % mod){
                RG int x = p[k + j], y = 1LL * w * p[k + j + i] % mod;
                p[k + j] = (x + y) % mod, p[k + j + i] = (x - y + mod) % mod;
            }
    }
    if(opt == -1){
        RG int inv = Pow(n, mod - 2);
        for(RG int i = 0; i < n; ++i) p[i] = 1LL * p[i] * inv % mod;
    }
}
IL void Inv(RG int *p, RG int *q, RG int len){//多项式求逆,p为A(x)，q为G(x)
    if(len == 1){
        q[0] = Pow(p[0], mod - 2);
        return;
    }
    Inv(p, q, len >> 1);
    for(RG int i = 0; i < len; ++i) a[i] = p[i], b[i] = q[i];
    RG int tmp = len << 1;
    NTT(a, tmp, 1), NTT(b, tmp, 1);
    for(RG int i = 0; i < tmp; ++i) a[i] = 1LL * a[i] * b[i] % mod * b[i] % mod;
    NTT(a, tmp, -1);
    for(RG int i = 0; i < len; ++i) q[i] = ((2 * q[i] - a[i]) % mod + mod) % mod;
    for(RG int i = 0; i < tmp; ++i) a[i] = b[i] = 0;
}
IL void Sqrt(RG int *p, RG int *q, RG int len){//多项式开方,p为A(x),q为G(x)
    if(len == 1){
        q[0] = sqrt(p[0]); //???
        return;
    }
    Sqrt(p, q, len >> 1), Inv(q, c, len);   
    RG int tmp = len << 1;
    for(RG int i = 0; i < len; ++i) a[i] = p[i];
    NTT(a, tmp, 1), NTT(c, tmp, 1);
    for(RG int i = 0; i < tmp; ++i) a[i] = 1LL * a[i] * c[i] % mod;
    NTT(a, tmp, -1);
    for(RG int i = 0; i < len; ++i) q[i] = 1LL * (q[i] + a[i]) % mod * inv2 % mod;
    for(RG int i = 0; i < tmp; ++i) a[i] = c[i] = 0;
}
IL void ICalc(RG int *p, RG int *q, RG int len){//多项式求导
    q[len - 1] = 0;
    for(RG int i = 1; i < len; ++i) q[i - 1] = 1LL * p[i] * i % mod;
}
IL void Calc(RG int *p, RG int *q, RG int len){//多项式积分
    q[0] = 0;
    for(RG int i = 1; i < len; ++i) q[i] = 1LL * Pow(i, mod - 2) * p[i - 1] % mod;
}
IL void Ln(RG int *p, RG int *q, RG int len){//多项式求ln
    Inv(p, c, len), ICalc(p, a, len);
    RG int tmp = len << 1;
    NTT(c, tmp, 1), NTT(a, tmp, 1);
    for(RG int i = 0; i < tmp; ++i) c[i] = 1LL * c[i] * a[i] % mod;
    NTT(c, tmp, -1), Calc(c, q, len);
    for(RG int i = 0; i < tmp; ++i) a[i] = c[i] = 0;
}
IL void Exp(RG int *p, RG int *q, RG int len){//多项式求exp
    if(len == 1){
        q[0] = 1;
        return;
    }
    Exp(p, q, len >> 1), Ln(q, b, len);
    for(RG int i = 0; i < len; ++i) b[i] = (mod - b[i] + p[i]) % mod, c[i] = q[i];
    b[0] = (b[0] + 1) % mod;
    RG int tmp = len << 1;
    NTT(b, tmp, 1), NTT(c, tmp, 1);
    for(RG int i = 0; i < tmp; ++i) b[i] = 1LL * b[i] * c[i] % mod;
    NTT(b, tmp, -1);
    for(RG int i = 0; i < len; ++i) q[i] = b[i];
    for(RG int i = 0; i < tmp; ++i) b[i] = c[i] = 0;
}
IL void CalcPow(RG int *p, RG int *q, RG int len, RG int y){//多项式求幂
    Ln(p, d, len);
    for(RG int i = 0; i < len; ++i) d[i] = 1LL * d[i] * y % mod;
    Exp(d, q, len);
    for(RG int i = 0; i < len; ++i) d[i] = 0;
}
int f[maxn], h[maxn], n, k, len;

IL void Record(){
    for(RG int i = 0; i < len; ++i) f[i] = h[i], h[i] = 0;
}
int main(){
    freopen("polynomial.in", "r", stdin);
    freopen("polynomial.out", "w", stdout);
    n = Input() - 1, k = Input();
    for(RG int i = 0; i <= n; ++i) f[i] = Input();
    for(len = 1; len <= n; len <<= 1);
    Sqrt(f, h, len), Record();
    Inv(f, h, len), Record();
    Calc(f, h, n + 1), Record();
    Exp(f, h, len), Record();
    Inv(f, h, len), Record();
    f[0] = (f[0] + 1) % mod;
    Ln(f, h, len), Record();
    f[0] = (f[0] + 1) % mod;
    CalcPow(f, h, len, k), Record();
    ICalc(f, h, n + 1);
    for(RG int i = 0; i <= n; ++i) printf("%d ", h[i]);
    return 0;
}
```

### 多项式除法及取模（待补）



### BSGS算法（求最小的x满足 a^x = b (mod n) n为质数）

```
const int MOD = 76543;
int hs[MOD],head[MOD],Next[MOD],id[MOD],top;
void insert(int x,int y)
{
    int k = x%MOD;
    hs[top] = x, id[top] = y, Next[top] = head[k], head[k] = top++;
}
int find(int x)
{
    int k = x%MOD;
    for(int i = head[k]; i != -1; i = Next[i])
        if(hs[i] == x)
            return id[i];
    return -1;
}
int BSGS(int a,int b,int n)//a^x = b(mod n)
{
	a%=n;b%=n;
    memset(head,-1,sizeof(head));
    top = 1;
    if(b == 1)return 0;
    int m = sqrt(n*1.0), j;
    long long x = 1, p = 1;
    for(int i = 0; i < m; ++i, p = p*a%n)insert(p*b%n,i);
    for(long long i = m; ;i += m)
    {
        if( (j = find(x = x*p%n)) != -1 )return i-j;
        if(i > n)break;
    }
    return -1;
}
```

### ex_BSGS算法 （n不为质数）

```c++
const int N = 1e5+3;//一定为素数
ll point[N*2],Next[N*2],val[N*2],pla[N*2],tot;
void add(ll x,ll y){
    ll xx=x%N;
    Next[++tot]=point[xx];
    val[tot]=x;
    pla[tot]=y;
    point[xx]=tot;
}
ll find(ll x){
    ll i;
    ll xx=x%N;
    for (i=point[xx];i;i=Next[i]){
        if (val[i]==x)return pla[i];
    }
    return -1;
}
ll gcd(ll a,ll b){
    return b==0?a:gcd(b,a%b);
}
ll qpow(ll a,ll b,ll mod){
    ll ans;
    for (ans=1;b;a=a*a%mod,b>>=1){
        if (b&1)ans=ans*a%mod;
    }
    return ans;
}
ll ex_BSGS(ll a,ll b,ll p){// a^x = b (mod p) 
    a%=p;b%=p;
    ll i;
    if (b==1)return 0;
    ll t=gcd(a,p),d=1,k=0;
    while (t!=1){
        if (b%t)return -1;
        b/=t;
        p/=t;
        d=d*(a/t)%p;
        k++;
        if (b==d)return k;
        t=gcd(a,p);
    }
    memset (point,0,sizeof(point));
    memset (Next,0,sizeof(Next));
    tot=0;
    ll m=ceil(sqrt(p));
    ll am=qpow(a,m,p);
    ll mul=b;
    add(mul,0);
    for (i=1;i<=m;i++){
        mul=mul*a%p;
        add(mul,i);
    }
    for (i=1;i<=m+1;i++){
        d=d*am%p;
        ll place=find(d);
        if (place!=-1)return i*m-place+k;
    }
    return -1;
}
```






