## 数论

### GCD

 斐波那契与GCD

​	 $gcd(F_n,F_m)=F_{gcd(n,m)}$

如果 a与b互质

​	 $gcd(a^m-b^m,a^n-b^n)=a^{gcd(m,n)}-b^{gcd(m,n)}$  0<=m<n

### 原根

```c++
	memset(vis,0,sizeof(vis));
    for(int i=2;i<N;i++){
        if(vis[i])continue;
        int j = 2*i;
        while(j<N){vis[j]=1;j+=i;}
    }
    for(int i=2;i<N;i++)if(!vis[i])P.pb(i);
    int p;scanf("%d",&p);
    int pp = p;
    p-=1;
    vector<int>tmp;
    for(int i=0;P[i]*P[i]<=p;i++){
        if(p%P[i]==0){
            tmp.pb(P[i]);
            while(p%P[i]==0){p/=P[i];}
        }
    }
    if(p!=1)tmp.pb(p);
    int ans=-1;
    for(int i=2;;i++){
        int flag=1;
        for(int j=0;j<(int)tmp.size();j++){
            int t=modexp(i,(pp-1)/tmp[j],pp);
            if(t==1)
                flag=0;
        }
        if(flag){ans=i;break;}
    }printf("%d\n",ans);
```

### 二次剩余

​	当存在某个x，式子$x^2=d(modp)$成立时，称d是模p的二次剩余

​	当对任意不成立时，称d是模p的二次非剩余

​	两个二次剩余的乘积必然还是二次剩余

	#### 欧拉准则

​	若p是奇质数且p不能整除d，则：

​		d是模p的二次剩余当且仅当：

​			 $d^{\frac{p-1}{2}}=1(modp)$

​		d是模p的二次非剩余当且仅当：

​			 $d^{\frac{p-1}{2}}=-1(modp)$ 

​	以勒让德符号表示，即为：

​		 $d^{\frac{p-1}{2}}=(\frac{d}{p})(modp)$ 

#### 勒让德符号

​	 $(\frac{a}{p})=1,a在模p意义下是二次剩余$ 

​	 $(\frac{a}{p})=-1,a在模p意义下是非二次剩余$ 

​	 $(\frac{a}{p})=0,a=0(modp)$ 

#### 求解方法

​	设a满足$\omega=a^2-n$是模p的非二次剩余，即$x^2=\omega(modp)$无解

​	那么$x=(a+\sqrt{\omega})^{\frac{p+1}{2}}$是二次同余方程$x^2=n(modp)$的解

​	我们可以通过随机选择a的值来找到一个满足条件的解，找到正解所需的次数的期望只有2 

```
#include <iostream>   
#include <ctime>
using namespace std;
typedef long long LL;
#define random(a,b) (rand()%(b-a+1)+a)
LL quick_mod(LL a, LL b, LL c) { LL ans = 1; while (b) { if (b % 2 == 1)ans = (ans*a) % c; b /= 2; a = (a*a) % c; }return ans; }
 
LL p;
LL w;//二次域的D值
bool ok;//是否有解
 
struct QuadraticField//二次域
{
	LL x, y;
	QuadraticField operator*(QuadraticField T)//二次域乘法重载
	{
		QuadraticField ans;
		ans.x = (this->x*T.x%p + this->y*T.y%p*w%p) % p;
		ans.y = (this->x*T.y%p + this->y*T.x%p) % p;
		return ans;
	}
	QuadraticField operator^(LL b)//二次域快速幂
	{
		QuadraticField ans;
		QuadraticField a = *this;
		ans.x = 1;
		ans.y = 0;
		while (b)
		{
			if (b & 1)
			{
				ans = ans*a;
				b--;
			}
			b /= 2;
			a = a*a;
		}
		return ans;
	}
};
 
LL Legender(LL a)//求勒让德符号
{
	LL ans=quick_mod(a, (p - 1) / 2, p);
	if (ans + 1 == p)//如果ans的值为-1，%p之后会变成p-1。
		return -1;
	else
		return ans;
}
 
LL Getw(LL n, LL a)//根据随机出来a的值确定对应w的值
{
	return ((a*a - n) % p + p) % p;//防爆处理
}
 
LL Solve(LL n)
{
	LL a;
	if (p == 2)//当p为2的时候，n只会是0或1，然后0和1就是对应的解
		return n;
	if (Legender(n) == -1)//无解
		ok = false;
	srand((unsigned)time(NULL));
	while (1)//随机a的值直到有解
	{
		a = random(0, p - 1);
		w = Getw(n, a);
		if (Legender(w) == -1)
			break;
	}
	QuadraticField ans,res;
	res.x = a;
	res.y = 1;//res的值就是a+根号w
	ans = res ^ ((p + 1) / 2);
	return ans.x;
}
 
int main()
{
	LL n,ans1,ans2;
	while (scanf("%lld%lld",&n,&p)!=EOF)
	{
		ok = true;
		n %= p;
		ans1 = Solve(n);
		ans2 = p - ans1;//一组解的和是p
		if (!ok)
		{
			printf("No root\n");
			continue;
		}
		if (ans1 == ans2)
			printf("%lld\n", ans1);
		else
			printf("%lld %lld\n", ans1, ans2);
	}
}
```



### 区间素数筛

```c++
const int MAXN = 1e6+1e3;   //待筛的区间[L,R]长度
const int N = 50001;//保证大于(2^31-1)的算数平方根
bool prime[MAXN];
bool seive[N];
typedef long long ll;
int len;
void init()
{
        for(int i=2;i<N;i++) seive[i]=1;
        for(int i=2;i*i<N;i++)  //预处理
            if(seive[i])
                for(int j=2*i;j<N;j+=i)
                    seive[j]=false;
}
void seg_seive(ll L,ll R)   //区间筛法
{
    len=R-L+1;
    for(int i=0;i<len;i++) prime[i]=1;
    if(1-L>=0) prime[1-L]=0;   //易错因为1不是素数也不是合数，这也是区间筛的一个易错bug
    for(ll i=2; i*i<=R ;i++)
    {
        if(seive[i])
        {
            for(ll j=max((ll)2,(L-1+i)/i)*i;j<=R;j+=i)  //第二个易错点，j必须从大于1，因为L可能小于i，但是seive[i]是素数。
                prime[j-L]=false;
        }
    }
}
```

### 大质数判定与大数分解

```
typedef long long LL;
LL ans;
LL modmul(LL a,LL b,LL mod)
{
    LL ret=0;
    for(;b;b>>=1,a=(a+a)%mod)
        if(b&1)ret=(ret+a)%mod;
    return ret;
}
LL qpow(LL x,LL u,LL mod)
{
    LL ret=1LL;
    for(;u;u>>=1,x=modmul(x,x,mod))
        if(u&1)ret=modmul(ret,x,mod);
    return ret;
}
LL gcd(LL a,LL b)
{
    return b?gcd(b,a%b):a;
}
LL Pollard_Rho(LL n,LL c)
{
    LL i=1,j=2,x=rand()%(n-1)+1,y=x;
    while(1)
    {
        i++;
        x=(modmul(x,x,n)+c)%n;
        LL p=gcd((y-x+n)%n,n);
        if(p!=1&&p!=n)return p;
        if(y==x)return n;
        if(i==j)
        {
            y=x;
            j<<=1;
        }
    }
}
bool Miller_Rabin(LL n)//判断是否为质数
{
    LL x,pre,u=n-1;
    int i,j,k=0;
    if(n==2||n==3||n==5||n==7||n==11)return 1;
    if(n==1||!(n%2)||!(n%3)||!(n%5)||!(n%7)||!(n%11))return 0;
    while(!(u&1))
    {
        k++;
        u>>=1;
    }
    srand((long long)12234336);
    for(i=1;i<=50;i++)
    {
        x=rand()%(n-2)+2;
        if(!(n%x))return 0;
        x=qpow(x,u,n);
        pre=x;
        for(j=1;j<=k;j++)
        {
            x=modmul(x,x,n);
            if(x==1&&pre!=1&&pre!=n-1)return 0;
            pre=x;
        }
        if(x!=1)return 0;
    }
    return 1;
}
LL prime[1000];int tot=0;
void find(LL n,LL c)//大数分解，c为任意值
{
    if(n==1)return;
    if(Miller_Rabin(n))
    {
        prime[tot++]=n;
        return;
    }
    LL x=n,k=c;
    while(x==n)x=Pollard_Rho(x,c--);
    find(n/x,k);
    find(x,k);
}
```



### 威尔逊定理

当且仅当p为质数，p可整除(p-1)!+1 ，即p|((p-1)!+1)

### 欧拉定理

若a,p为正整数且a,p互质 ，则$a^{φ(p)} \equiv 1 (mod p)$ 

### 扩展欧拉定理

 $gcd(a,p)=1时，a^b=a^{b \% \varphi(p)} (mod p)$

 $gcd(a,p)\not =1且b>=\varphi(p)时，a^b=a^{b \% \varphi(p)+\varphi(p)} (mod p)$

### 费马小定理

若p是质数，则$a^{p-1}\equiv 1 (mod p)$ 

### 费马大定理

 $a^n+b^n=c^n$ 当n>2时无整数解

### 中国剩余定理

```
//模数互质的情况，m[] 存模数，a[] 存模后的结果
ll m[N],a[N];
ll exgcd(ll a,ll b,ll &x,ll &y)
{
    if(b==0){x=1LL;y=0;return a;}
    ll r=exgcd(b,a%b,y,x);
    y-=a/b*x;
    return r;
}
ll china(ll n,ll *m,ll *a)
{
    ll M=1,d,y,x=0;
    for(int i=0;i<n;i++) M*=m[i];
    for(int i=0;i<n;i++){
        ll w=M/m[i];
        exgcd(m[i],w,d,y);
        x=(x+y*w*a[i])%M;
    }
    return (x+M)%M;
}
```

```
//模数不互质
struct China
{
    #define ll long long
    ll gcd(ll a,ll b){return b==0?a:gcd(b,a%b);}
    ll exgcd(ll a,ll b,ll &x,ll &y)
    {
        if(b==0){x=1LL;y=0;return a;}
        ll r=exgcd(b,a%b,y,x);
        y-=a/b*x;
        return r;
    }
    //a在模n乘法下的逆元，没有则返回-1
    ll inv(ll a,ll n)
    {
        ll x,y;
        ll t=exgcd(a,n,x,y);
        if(t!=1)return -1;
        return(x%n+n)%n;
    }
    //合并两个方程
    bool merge(ll a1,ll n1,ll a2,ll n2,ll& a3,ll& n3)
    {
        ll d=gcd(n1,n2);
        ll c=a2-a1;
        if(c%d)return false;
        c=(c%n2+n2)%n2;
        c/=d;n1/=d;n2/=d;
        c*=inv(n1,n2);
        c%=n2;c*=n1*d;
        c+=a1;
        n3=n1*n2*d;
        a3=(c%n3+n3)%n3;
        return true;
    }
    //求模线性方程组x=ai(mod ni) 可以不互质
    ll china(int len,ll* a,ll* n)
    {
        ll a1=a[0],n1=n[0];
        ll a2,n2;
        for(int i=1;i<len;i++){
            ll aa,nn;
            a2=a[i],n2=n[i];
            if(!merge(a1,n1,a2,n2,aa,nn))return -1;
            a1=aa;n1=nn;
        }
        return (a1%n1+n1)%n1;
    }
}china;
```





### 扩展欧几里得

```C++
ll exgcd(ll a,ll b,ll &x,ll &y)
{
    if(b==0){x=1LL;y=0;return a;}
    ll r=exgcd(b,a%b,y,x);
    y-=a/b*x;
    return r;
}
// by+(a-a/b*b)x = ax+b(y-a/b*x)
```

### 欧拉函数

```
//o(n)
void init_euler()
{
	memset(p1,0,sizeof(p1));
	memset(phi,0,sizeof(phi));
	memset(vis,0,sizeof(vis));
	for(int i=2;i<N;i++){
		if(!vis[i]){p1[++p1[0]]=i;phi[i]=i-1;}
		for(int j=1;j<=p1[0];j++){
			if(i*p1[j]>=N)break;
			vis[i*p1[j]]=true;
			if(!(i%p1[j])){phi[i*p1[j]]=phi[i]*p1[j];break;}
			phi[i*p1[j]]=phi[i]*(p1[j]-1);
		}
	}phi[1]=1;
	pre[0]=0;
	for(int i=1;i<N;i++)pre[i]=(pre[i-1]+phi[i])%p;
}
```

### 莫比乌斯函数

```c++
//o(n)
void init_mus()
{
	cnt=0;memset(vis,0,sizeof(vis));
	mus[1]=1;
	for(int i=2;i<N;i++){
		if(!vis[i]){prime[cnt++]=i;mus[i]=-1;}
		for(int j=0;j<cnt&&i*prime[j]<N;j++){
			vis[i*prime[j]]=1;
			if(i%prime[j]==0){mus[i*prime[j]]=0;break;}
			else mus[i*prime[j]]=-mus[i];
		}
	}
}
```

### 数论函数

​	积性函数：对于**任意互质的整数**a和b有性质$f(ab) = f(a)f(b)$的数论函数

​	完全积性函数：对任意整数a和b有性质$f(ab) = f(a)f(b)$的数论函数

​	约数函数：$\sigma_{k} = \sum_{d|n}^{}d^{k}$

​	原函数    ：$e = [n = 1]$

​	恒等函数：$I = 1$

​	单位函数：$ID = n$

​	幂函数    ：$ID^{k} = n^{k}$   $ID^{0} =  I$

​	狄利克雷卷积及其他：

​		卷积    ：$(a \times b)(n) = \sum_{d|n}a(d)b(\frac{n}{d})$

​		乘        ：$(a \cdot b) = a(n)b(n)$

​		加        ：$(a+b)(n) = a(n) + b(n)$

​		交换律：$a \times b = b \times a$

​		结合律：$(a \times b) \times c = a \times (b \times c)$

​		分配率：$(a + b) \times c = a \times c + b \times c$

​		单位元：$a \times e = a$

​		注意    ：$a \cdot e = e$

​		单位元的逆元(莫比乌斯函数)：$\mu \times I = e$

​		莫比乌斯反演：$f = g \times I \Leftrightarrow g = f \times \mu$

​		欧拉函数的卷积：$\phi \times I = ID \Leftrightarrow \phi = ID \times \mu$

​		恒等函数的卷积：$I \times I = \sigma_{0} \Leftrightarrow I = \sigma_{0} \times \mu$

​		幂函数的卷积：$ID^{k} \times I = \sigma_{k} \Leftrightarrow ID^{k} = \sigma_{k} \times \mu$

 		若：					 $b(x)b(\frac{n}{x}) = c(n)$

​		则：			 $(a \cdot b^{k}) \times b^{k} = \sum_{d|n}a(d)b(d)b(\frac{n}{d}) = (a \times I) \cdot c^{k}(n)$

​		另外一种表述：g在完全积性条件下：			

​					 $(f \cdot g) \times g = (f \times I) \cdot g$	

​		例子：由				 $ID^{k}(d)ID^{k}(\frac{n}{d}) = ID^{k}(n)$

​		可得：			 $(a \cdot ID^{k}) \times ID^{k} = (a \times I) \cdot ID^{k}$				 

​						 $(\phi \cdot ID^{k}) \times ID^{k} = (\phi \times I) \cdot ID^{k} = ID \cdot ID^{k} = ID^{k+1}$					 

​						 $(\mu \cdot ID^{k}) \times ID^{k} = (\mu \times I) \cdot ID^{k} = e \cdot ID^{k} = e$				 		

​						 $ID^{k} \times ID^{k} = (I \cdot ID^{k}) \times ID^{k} = (I \times I) \cdot ID^{k} = \sigma_{0} \cdot ID^{k}$

### 莫比乌斯反演

​	定义$F(n)=\sum_{d|n}f(d)$ 则 $f(n)=\sum_{d|n}\mu(d)F(\frac{n}{d})$ 

​	定义$F(n)=\sum_{n|d}f(d)$ 则$f(n)=\sum_{n|d}\mu(\frac{d}{n})F(d)$ 

​	推广式：

​		设f,g为两个数论函数，t为一个完全积性函数，且$t(1)=1$,有

​			 $f(n)=\sum_{k=1}^nt(k)g(\lfloor\frac{n}{k}\rfloor)$ 

​		则      $g(n)=\sum_{k=1}^n\mu(k)t(k)f(\lfloor\frac{n}{k}\rfloor)$ 

### 杜教筛

​	设$f(n)$为一个数论函数，需要计算$S(n)=\sum_{i=1}^nf(i)$ 

​	找到一个适合的数论函数$g(n)$ 

​		 $\sum_{i=1}^n\sum_{d|i}f(d)g(\frac{i}{d})=\sum_{i=1}^ng(i)\sum_{j=1}^{\frac{n}{i}}f(j)=\sum_{i=1}^ng(i)S(\frac{	n}{i})$ 

​		 $g(1)S(n)=\sum_{i=1}^nf\times g-\sum_{i=2}^ng(i)S(\frac{n}{i})$ 

​	构造的卷积函数$f\times g$必须容易求得前缀和

### 洲阁筛

给出一个积性函数$F(x)$,满足积性函数的基本性质：

​	 $F(1)=1$,如果a和b互质，则$F(ab)=F(a)F(b)$ 

​	设$x=\prod p_i^{k_i}$ 则有 $F(x)=\prod F(p_i^{k_i})$ 

​	特别地，p为质数，$F(p)$是一个低阶多项式，$F(p^c)$可以快速算出

现在要求	 $\sum_{i=1}^nF(i),n<=1e11$

小范围问题的解决方法：

​	假如n在$10^7$范围内，考虑怎么线性求出每一个$F(x)$ 

​	分析线性筛的过程，大概分为几个要点：

​		1.质数的时候需要直接计算

​		2.对于某个非质数x，会分解为两部分：最小的质因数p和剩余的部分y，有py=x

​	质数部分只能直接算

​	非质数的部分分为3类

​		1.p和y互质，那么显然$F(x)=F(p)F(y)$ 

​		2.y是p的幂$y=p^c$,也就是y中只有p一个因子，此时需要知道次数c然后直接计算

​		3.y是p的倍数$p|y$,但是y中还有其他的质因子，设$y=p^cz$,则$F(x)=F(z)F(p^{c+1})$。

​		如果我们知道$p^c$,那么我们就可以这么计算：$F(x)=F(\frac{y}{p^c})F(p^c\ast p)$ 

​	我们需要知道每个数最小的质因子的次数$cnt[x]$,每个数中最小的质因子构成的部分$fir[x]$

​	线性筛的过程：

​		1.由之前的结果判断i是否是质数，质数的情况下，直接算出$F(i),fir[i]=i,cnt[i]=1$。

​		2.枚举已经求出的质数$p[j]$ ,将$i\ast p[j]$设为非质数

​		3.判断$p[j]$是否是i的因数

​		4.如果不是，$F(i\ast p[j])=F(i)F(p[j]),fir[i\ast p[j]]=p[j],cnt[i\ast p[j]]=1$			 

​		5.如果是，判断i是否等于$fir[i]$,当$i=fir[i]$时，i中只有$p[j]$一个质因数，此时$F(i\ast p[j])=F(p[j]^{cnt[i]+1})$ 

​			按照定义直接算。否则$F(i\ast p[j])=F(\frac{i}{fir[i]})F(fir[i]\ast p[j])$ 

​			然后无论如何$fir[i\ast p[j]]=fir[i]\ast p[j],cnt[i\ast p[j]]=cnt[i]+1$ 

大范围问题求解方法：

​	我们把1~n的每一个数分类，有大于$\sqrt{n}$的质数的，和没有的

​		 $\sum_{i=1}^nF(i)=\sum_{i=1}^{\sqrt{n}}F(i)(\sum_{p>\sqrt{n}}^{\lfloor\frac{n}{i}\rfloor}F(p)[p为质数])+\sum_{i=1}^nF(i)[i无大于\sqrt{n}的质因子]$ 

​	有大于$\sqrt{n}$的质因子的，我们枚举$<=\sqrt{n}$的质因子部分，再枚举$>\sqrt{n}$的质因子，没有的就直接枚举

​	算法可以分为三部分：

​		第一部分是枚举$\sqrt{n}$内每一个i，求F(i)，这部分我们可以线性筛

​		第二部分是对于每一个$\lfloor\frac{n}{i}\rfloor$,求$\sum_{p>\sqrt{n}}^{\lfloor\frac{n}{i}\rfloor}F(p)[p为质数]$ 

​		第三部分求$\sum_{i=1}^nF(i)[i无大于\sqrt{n}的质因子]$ 

​	第二部分：求$\sum_{p>\sqrt{n}}^{\lfloor\frac{n}{i}\rfloor}F(p)[p为质数]$ 

​		我们只要筛掉$\sqrt{n}$内的所有质数，那么剩下的就是我们要求的

​		考虑怎样化简问题，因为F(p)是一个低阶的多项式，所以我们只需要对于每一项单独求和，第k项

​		求出$\sum p^k$,然后合并即可

​		即现在的问题是，对于某个范围[1,m]内的所有大于$\sqrt{n}$的质数，求$\sum p^k$ 

​		筛的过程可用递推实现

​		设小于等于$\sqrt{n}$的质数有$P_n$个，从小到大的排列为$P_{1...P_n}$ 

​		设在[1,j]中，与$P_{1...i}$互质的所有数的k次方和为：$g[i][j]$ 

​		显然边界为$g[0][j]=\sum_{i=1}^ji^k$ ,我们要求的为$g[p_n][j]$ 

​		考虑怎样从前i-1个质数推到前i个质数

​		我们只需要算出与前i-1个质数互质的数的k次方和，再减去与前i-1个数互质但不予第i个数互质数的k次方和即可

​		设某个与前i-1个质数互质的数为x，那么$P[i]x$必然与第i个质数不互质

​		 $\sum(P[i]x)^k=P[i]^k\sum x^k$ 又$P[i]x<=j$,那么有$x<=\lfloor\frac{j}{P[i]}\rfloor$ 

​		所以 $g[i][j]=g[i-1][j]-P_i^kg[i-1][\lfloor\frac{j}{P[i]}\rfloor]$ 

​		注意到$P[i]>P[i-1]>\lfloor\frac{j}{P[i]}\rfloor,即P[i]^2>j$时，有$g[i][j]=g[i-1][j]-P_i^k$ 

​		那么设$P_{L[j]}^2>j>=P_{L[j]-1}^2$ 

​		对于$i<L[j]$我们需要老老实实去算，对于$i>=L[j]$我们只需要一个前缀和

​		此外，如果$P[i]>j$,此时$\lfloor\frac{j}{P[i]}\rfloor=0$,那么有$g[i][j]=g[i-1][j]$ 

​		设小于等于j的质数有cntp[j]个,那么对于$i>=cntp[j]$是不需要计算的

​		综合起来，根据i的大小，可以分为3端

​			第一段0到L[j]-1,直接算

​			第二段L[j]到cntp[j],预处理p^k的前缀和

​			第三段cntp[j]到$P_n$,不需要算

​		观察到递推式只和i-1有关，是可以滚动数组的：

​			当$i<L[j]$时，直接$g[j]=g[j]-P_i^kg[\lfloor\frac{j}{P[i]}\rfloor]$ 

​			当$i>=L[j]$时，停止对g[j]的递推

​			如果在某个i调用到了g[i],那么我们再算上缺少的$L[j]$到min(i,cntp[j])的部分的前缀和即可

​			设前缀和为$sump[i]=\sum_{t=0}^ip_t^k$,那么我们可以这样表示$g[i][j]$ 

​			 $g[j]+max(0,sump[min(i,cntp[j])]-sump[L[j]])$ 

​		细节：

​			1.cntp[j]只需要保存$j<=\sqrt{n}$的，因为当$j>\sqrt{n}$时，所有i都满足$P_i<j$.此时只要当$cntp[j]=P_n$ 

​			2.由于j的范围是[1,n]，我们可以分类存放

​				当$j<=\sqrt{n}$,我们直接开数组，存放在g0[j]

​				当$j>\sqrt{n}$，设$\lfloor\frac{n}{x}\rfloor=j$，存放在g1[x]

​			3.由于使用了滚动数组，所以j到从大到小枚举。而L[j]是随着j减小而减小的，而我们枚举的条件是$i<L[j]$

​			所以在$i>=L[j]$直接停止枚举即可

​	第三部分：求$\sum_{i=1}^nF(i)[i无大于\sqrt{n}的质因子]$ 

​		同样我们用递归去求，这次为了方便，我们从大的质数往小的质数去推

​		没有大于$\sqrt{n}$的质因子，那么意味着只有$\sqrt{n}$以内的质因子

​		所以我们设：x在[1,j]的范围内，只有$P_{i...P_n}$这些质因子的数

​			 $f[i][j]=\sum F(x)$ ，边界为$f[P_n+1][j]=1$ ，要求的为$f[0][j]$ 

​		那么有：$f[i][j]=f[i+1][j]+\sum F(P_i^c)f[i+1][\lfloor\frac{j}{P_i^c}\rfloor]$ 

​			简单来说，直接枚举当前质因子的幂，然后考虑乘起来不会超过j的，只包含$P_{i+1...n}$的数的和为多少

​			因为是积性函数，所以可以直接乘起来

​		同样考虑$P_i^2>j$，则$\lfloor\frac{j}{P_i}\rfloor<P_i$，此时$f[i+1][\lfloor\frac{j}{P_i}\rfloor]=1$(因为只包含大于$P_i$的质数)

​		而当$c>=2,\lfloor\frac{j}{P_i^c}\rfloor=0$ 

​		所以，同样根据i的大小分为3段。(注意是从大到小的)

​			第一段$P_n$到$cntp[i]+1$,这一段不用计算

​			第二段$cntp[i]$到$L[i]$,这一段我们要计算F(p)的前缀和

​			第三段$L[i]-1$到0，这一段老老实实递归

​		同样的可以用滚动数组

​			设前缀和为$sump[i]=\sum_{t=1}^iF(t)$ 

​			那么，在某个i时，f[j]的实际值为$f[j]+max(0,sump[L[i]-1]-sump[max(i,cntp[i])-1])$ 

​		细节：同样，当$j<=\sqrt{n}$时，即为f0[j]，否则设$j=\lfloor\frac{n}{x}\rfloor$，记为f1[j]

​	最后答案为：$ans=\sum_{i=1}^{\sqrt{n}}F(i)g(\lfloor\frac{n}{i}\rfloor)+f(n)=\sum_{i=1}^{\sqrt{n}}F(i)g1(i)+f1(1)$  

```
#include <bits/stdc++.h>

using namespace std;

#define ll long long
const int N = 1e7+5;
int p[N],fir[N],cnt[N],tot;
ll F[N],pre[N];
bool vis[N];
void init()
{
    tot=0;fir[1]=cnt[1]=F[1]=1;
    for(int i=2;i<N;i++){
        if(!vis[i]){p[tot++]=i;F[i]=4;fir[i]=i;cnt[i]=1;}//这里是质数，根据题目修改F[i]
        for(int j=0;j<tot&&p[j]*i<N;j++){
            vis[i*p[j]]=true;    
            if(i%p[j]==0){
                fir[i*p[j]]=fir[i]*p[j];cnt[i*p[j]]=cnt[i]+1;
                if(i==fir[i])F[i*p[j]]=3*cnt[i*p[j]]+1;//这里只有一个质因数，根据题目修改等式
                else F[i*p[j]]=F[i/fir[i]]*F[fir[i*p[j]]];
                break;
            }
            F[i*p[j]]=F[i]*F[p[j]];
            fir[i*p[j]]=p[j];cnt[i*p[j]]=1;
        }
    }
    pre[0]=0;for(int i=1;i<N;i++)pre[i]=pre[i-1]+F[i];
}
const int SqrtN = sqrt(1e11+5);
int L0[SqrtN],L1[SqrtN],cntp[SqrtN];//所需空间为sqrt(n)
ll g0[SqrtN],g1[SqrtN],f0[SqrtN],f1[SqrtN],sump[SqrtN],ans2[SqrtN];
void ask2(ll n,ll k,ll sqrtn,ll pn){
    for(int i=1;i<sqrtn;i++)g0[i]=i,g1[i]=n/i;//这里处理自然数的前k次方和,根据题目修改
    //这里处理质数的前k次方和 根据题目修改 注意这里的下标第i个质数是p[i-1]
    sump[0]=0;for(int i=1;i<=pn;i++)sump[i]=sump[i-1]+1;
    for(int i=0;i<pn;++i){
        for(int j=1;j<sqrtn&&i<L1[j];++j){
            ll y=n/j/p[i];
            g1[j]-=(y<sqrtn?
                (g0[y]-(min(i,cntp[y])>L0[y]? sump[min(i,cntp[y])]-sump[L0[y]]:0)):
                (g1[n/y]-(i>L1[n/y]? sump[i]-sump[L1[n/y]]:0)));
        }
        for(int j=sqrtn-1;j>=1 && i<L0[j];--j){
            ll y=j/p[i];
            g0[j]-=(g0[y]-(min(i,cntp[y])>L0[y]? sump[min(i,cntp[y])]-sump[L0[y]]:0));
        }
    }
    for(int i=1;i<sqrtn;++i){
        g0[i]-=sump[cntp[i]]-sump[L0[i]]+1;
        g1[i]-=sump[pn]-sump[L1[i]]+1;
    }
}
void ask3(ll n,ll sqrtn,ll pn){
    for(int i=1;i<sqrtn;++i) f0[i]=f1[i]=1;
    //这里处理质数的F(p)的前缀和 根据题目修改 注意第i个质数为p[i-1]
    sump[0]=0;for(int i=1;i<=pn;i++) sump[i]=sump[i-1]+4;
    for(int i=pn-1;i>=0;--i){
        for(int j=1;j<sqrtn && i<L1[j];++j){
            ll y=n/j/p[i];
            for(int c=1;y;y/=p[i],++c)//这里枚举质因子的幂
                f1[j]+=(3*c+1)*((y<sqrtn)?//这里根据题目改(3c+1)也就是F(p^c)
                    (f0[y]+(cntp[y]>max(i+1,L0[y])?sump[cntp[y]]-sump[max(i+1,L0[y])]:0)):
                    (f1[n/y]+sump[pn]-sump[max(i+1,L1[n/y])]));
        }
        for(int j=sqrtn-1;j>=1 && i<L0[j];--j){
            int y=j/p[i];
            for (int c=1;y;y/=p[i],++c)//这里枚举质因子的幂
                f0[j]+=(3*c+1)*
                (f0[y]+(cntp[y]>max(i+1,L0[y])?sump[cntp[y]]-sump[max(i+1,L0[y])]:0));
                //这里根据题目改(3c+1)也就是F(p^c)
        }
    }
    for (int i=1;i<sqrtn;++i){
        f0[i]+=sump[cntp[i]]-sump[L0[i]];
        f1[i]+=sump[pn]-sump[L1[i]];
    }
}
ll work(ll n)
{
    if(n<N)return pre[n];
    memset(ans2,0,sizeof(ans2));
    int sqrtn=1,pn=0;
    for(;1LL*sqrtn*sqrtn<=n;++sqrtn);
    for(;1LL*p[pn]*p[pn]<=n;++pn);
    L0[0]=0;
    for(int i=1;i<sqrtn;++i)for(L0[i]=L0[i-1];1LL*p[L0[i]]*p[L0[i]]<=i;++L0[i]);
    L1[sqrtn]=0;
    for (int i=sqrtn-1;i>=1;--i){
        ll x=n/i;
        for(L1[i]=L1[i+1];1LL*p[L1[i]]*p[L1[i]]<=x;++L1[i]);
    }
    cntp[0]=0;
    for(int i=1;i<sqrtn;++i) for(cntp[i]=cntp[i-1];p[cntp[i]]<=i;++cntp[i]);
    for(int i=0;i<=0;i++){//这里分别求第二部分F(p)的每一阶和
        ask2(n,i,sqrtn,pn);
        for(int j=1;j<sqrtn;j++)ans2[j]+=g1[j]*4;//这里根据i改每一阶的系数
    }
    ask3(n,sqrtn,pn);//这里求第三部分
    ll ans=f1[1];
    for(int i=1;i<sqrtn;i++){
        ans+=F[i]*ans2[i];
    }
    return ans;
}
int main()
{
    init();
    int T;scanf("%d",&T);
    while(T--){
        ll n;scanf("%lld",&n);
        printf("%lld\n",work(n));
    }
    return 0;
}
```

### min_25筛

​	对数论函数的条件与洲阁筛一样

​	首先我们需要对每个$x=⌊\frac{n}{i}⌋$求出$\sum_{i=1}^xf[i][i是质数]$  

​	先线性筛出小于$\sqrt{n}$的所有质数，为$P_{1...P_n}$ $prep[i]$为第i个质数的函数的前缀和

​	设函数：$S(x,j)=\sum_{i=2}^xf(i)[i为质数或i的最小质因子大于p_j]$ 

​	设$sum(n)=\sum_{i=1}^xf(i)$ (假设i是质数) 

​	显然对于任意的x,$S(x,0)=sum(x)-f(1) 我们要求的就是$$S(n,P_n)$ 

​	考虑转移：如果$p_j^2>x,S(x,j)=S(x,j-1)$ 

​	否则：$S(x,j)=S(x,j-1)-f(p_j)\ast (S(\lfloor\frac{x}{p_j}\rfloor,j-1)-prep[j-1])$  

​	通过这样可以求出大部分积性函数$f(x)$,当x为质数时的函数和，现在要求$\sum_{i=1}^nF(i)$ 

​	设函数：$G(x,j)=\sum_{i=2}^xF[i][i为质数或i的最小质因子大于p_j]$  $pref[x]=sum_{i=1}^xF(p_i)$ 

​		显然可以用已经求得的$S(x,P_n)$求解$G(x,P_n)$ 

​		 $G(x,j)=G(x,j+1)+\sum_{k=1}(G(\lfloor\frac{x}{p_j^k}\rfloor,j+1)-pref[j])\ast F(p_j^k)+\sum_{k=2}F(p_j^k)$ 

​		答案就是$G(n,0)$ 

```
#include <bits/stdc++.h>

#define N (10000005)
#define ll long long
#define pos(x) (x<=lim?x:(m-n/(x)+1))//求第x个数论分块后有用的数的下标

using namespace std;

int p[N],fir[N],cnt1[N],tot;
ll F[N],pre[N];
bool vis[N];
void init()
{
    tot=0;fir[1]=cnt1[1]=F[1]=1;
    for(int i=2;i<N;i++){
        if(!vis[i]){p[tot++]=i;F[i]=4;fir[i]=i;cnt1[i]=1;}//这里是质数，根据题目修改F[i]
        for(int j=0;j<tot&&p[j]*i<N;j++){
            vis[i*p[j]]=true;    
            if(i%p[j]==0){
                fir[i*p[j]]=fir[i]*p[j];cnt1[i*p[j]]=cnt1[i]+1;
                if(i==fir[i])F[i*p[j]]=3*cnt1[i*p[j]]+1;//这里只有一个质因数，根据题目修改等式
                else F[i*p[j]]=F[i/fir[i]]*F[fir[i*p[j]]];
                break;
            }
            F[i*p[j]]=F[i]*F[p[j]];
            fir[i*p[j]]=p[j];cnt1[i*p[j]]=1;
        }
    }
    pre[0]=0;for(int i=1;i<N;i++)pre[i]=pre[i-1]+F[i];
}
ll s[N],c[N],w[N],m,lim,cnt;
ll calc(ll x,ll y,ll n){//x表示[2,x]，y表示第y个质数
  if(x<=1||x<=p[y]) return 0;
  ll ans=s[pos(x)]-s[p[y]];//这里求(p[y],x]的质数对应的函数和
  for(ll j=y+1;j<=cnt &&p[j]*p[j]<=x;++j)//这里枚举对答案有贡献的质数
    for (ll z=x,c=1;(z/=p[j])>=p[j];++c)//这里枚举质数的幂
      ans=ans+calc(z,j,n)*(3*c+1)+(3*(c+1)+1);//这里根据题目修改 分别是 F(p[j]^c) F(p[j]^(c+1))
  return ans;
}
ll work(ll n){
    if(n<N)return pre[n];
    lim=1;m=cnt=0;p[0]=0;
    for(;lim*lim<=n;++lim);lim-=1;
    for(ll i=1;i<=n;i=w[m]+1)//w是数论分块后有用的数，s是质数的和，c是质数个数
        w[++m]=n/(n/i),s[m]=w[m]-1,c[m]=w[m]-1;//这里s[m]=w[m]-1代表假设所有数都是质数，它们的完全积性函数值之和再减去1对应的完全积性函数值，如果不是完全积性函数，必须将其拆分为若干个完全积性函数，然后分开算再将其求和 根据题目修改
    for(ll i=2;i<=lim;++i){
        if(c[i]==c[i-1]) continue; //如果等于i就不是质数
        p[++cnt]=i;//p存质数，下标从1开始,cnt表示有多少个质数
        for(int j=m,k;w[j]>=i*i;--j) s[j]-=1*(s[k=pos(w[j]/i)]-s[i-1]),c[j]-=c[k]-c[i-1];
        //s需要2sqrt(n)的空间，这里的s[j]-=1*中的1要根据前面质数的完全积性函数来修改 根据题目修改
    }
    //求出来的s[i]为[1,i]的质数和(不包括1),c[i]为[1,i]的质数个数和(不包括1)，
    //其中i代表第i个数论分块后有用的数的下标
    for(int i=1;i<=m;++i) s[i]=4*s[i];//这里乘上原本质数的函数值的系数 根据题目修改
    return calc(n,0,n)+1;//这里要将F[1]加上 根据题目修改
}
int main(){
    init();
    int T;scanf("%d",&T);
    while(T--){
        long long n;scanf("%lld",&n);
        printf("%lld\n",(long long)work(n));
    }
   return 0;
}
```





### 常用转换技巧

```
for(ll i=1;i*i<=n;i++){
            ll l=n/(i+1),r=n/i;
            (l,r]
            if(n/i!=i){
                [i,i]
            }
        }
```

 $1^2+2^2+...+n^2=\frac{n*(n+1)*(2n+1)}{6}$ 

 $1^3+2^3+...+n^3=(\frac{n*(n+1)}{2})^2$ 

  $\phi(n)=\sum_{i=1}^{n}\varphi(i)$ 

 $\sum_{i=1}^n\phi(\frac{n}{i})=\frac{1}{2}\lfloor n\rfloor \lfloor n+1\rfloor$

 $\phi(n)=\frac{1}{2}\sum_{i=1}^n\mu(i)\lfloor\frac{n}{i}\rfloor\lfloor1+\frac{x}{i}\rfloor$ 

 $\sum_{d=1}^n\mu(d)\lfloor\frac{n}{d}\rfloor=1$ 

容斥系数：

​	 $f(x)=\mu(x)$ 用于容斥出限制等于1的结果 搭配函数必须易于求出限制大于等于某一值的方案数

​	 $f(x)=\sum_{d|x}\mu(\frac{x}{d}),d为质数，d>1$ 用于容斥出限制为质数(不包括1)的结果，搭配函数必须易于求出限制大于等于某一值的方案数

前n个正整数的因数个数之和：

​	 $\sum_{i=1}^n\sigma_0(i)=\sum_{i=1}^n\lfloor\frac{n}{i}\rfloor$ 

​	 $n=\sum_{k=1}^n\mu(k)\sum_{i=1}^{\lfloor\frac{n}{k}\rfloor}\sigma_0(i)$ 

前n个平方数的因数个数之和：

​	 $\sum_{i=1}^n\sigma_0(i^2)=\sum_{i=1}^n\sum_{d|i}2^{w(d)}=\sum_{i=1}^n\sum_{d|i}\sum_{x|d}\mu^2(x)=\sum_{x=1}^n\mu^2(x)\sum_{i=1}^{\frac{n}{x}}\frac{n}{ix}$ 

前n个立方数的因数个数之和：

​	 $\sum_{i=1}^n\sigma_0(i^3)$ 用洲阁筛或min_25筛做

前m个正整数与n乘积的欧拉函数之和：

​	n有平方因子时，将多余因子提取出来再用下面的做法即可

​	这里n为无平方因子数，令$n\%p=0$ 

​	 $f(m,n)=\sum_{i=1}^m\varphi(i\ast n)=\varphi(p)\sum_{i=1,i\%p!=0}^m\varphi(i\ast \frac{n}{p})+\sum_{i=1}^{\frac{m}{p}}\varphi(i\ast p\ast n)$ 

​				 $n\%p=0$,有$\varphi(i\ast p\ast n)=\varphi(i\ast n)\ast p=\varphi(i\ast n)(\varphi(p)+1)$ 

​						 $=\varphi(p)(\sum_{i=1,i\%p!=0}^m\varphi(i\ast \frac{n}{p})+\sum_{i=1}^\frac{m}{p}\varphi(i\ast p\ast \frac{n}{p}))+\sum_{i=1}^{\frac{m}{p}}\varphi(i\ast n)$ 

​						 $=\varphi(p)\sum_{i=1}^m\varphi(i\ast \frac{n}{p})+\sum_{i=1}^{\frac{m}{p}}\varphi(i\ast n)$ 

​						 $=\varphi(p)f(m,\frac{n}{p})+f(\frac{m}{p},n)$ 

前m个正整数与n乘积的莫比乌斯函数之和：

​	 当n有平方因子时，答案为0

​	当n无平方因子时，令$n\%p=0$ 

​	 $f(m,n)=\sum_{i=1}^m\mu(i\ast n)=\mu(p)\sum_{i=1,i\%p!=0}^m\mu(i\ast \frac{n}{p})+\sum_{i=1}^{\frac{m}{p}}\mu(i\ast p\ast n)$ 

​				 $n\%p=0$,有$\mu(i\ast p\ast n)=\mu(i\ast n)\ast 0=\mu(i\ast n)(\mu(p)+1)$ 

​						 $=\mu(p)(\sum_{i=1,i\%p!=0}^m\mu(i\ast \frac{n}{p})+\sum_{i=1}^\frac{m}{p}\mu(i\ast p\ast \frac{n}{p}))+\sum_{i=1}^{\frac{m}{p}}\mu(i\ast n)$ 

​						 $=\mu(p)\sum_{i=1}^m\mu(i\ast \frac{n}{p})+\sum_{i=1}^{\frac{m}{p}}\mu(i\ast n)$ 

​						 $=-f(m,\frac{n}{p})+f(\frac{m}{p},n)$ 

​	另一种推法：

​		 $\sum_{i=1}^m\mu(i\ast n)=\sum_{i=1}^m\mu(i)\mu(n)[gcd(i,n)==1]$ 

​					 $=\sum_{i=1}^m\mu(i)\mu(n)\sum_{d|i,d|n}\mu(d)$ 

​					 $=\mu(n)\sum_{i=1}^m\mu(i)\sum_{d|i,d|n}\mu(d)$ 

​					 $=\mu(n)\sum_{d|n}\mu(d)\sum_{i=1}^{\lfloor\frac{m}{d}\rfloor}\mu(i\ast d)$ 

rng_58-clj等式：

​	 $\sum_{i=1}^a\sum_{j=1}^b\sum_{k=1}^{c}\sigma_0(ijk)=\sum_{gcd(i,j)=gcd(j,k)=gcd(k,i)=1}\lfloor\frac{a}{i}\rfloor\lfloor\frac{b}{j}\rfloor\lfloor\frac{c}{k}\rfloor$ 

​	这个等式可扩展至任意维

​	应用：

​		 $\sum_{i=1}^a\sum_{j=1}^b\sigma_0(ij)=\sum_{gcd(i,j)=1}\lfloor\frac{a}{i}\rfloor\lfloor\frac{b}{j}\rfloor=\sum_{g=1}^{min(a,b)}\mu(g)\sum_{i=1}^a\sum_{j=1}^b\lfloor\frac{a}{ig}\rfloor\lfloor\frac{b}{jg}\rfloor$ 

​					定义$f(n)=\sum_{i=1}^{n}\lfloor\frac{n}{i}\rfloor$ 

​						 $=\sum_{g=1}^{min(a,b)}\mu(g)f(\lfloor\frac{a}{g}\rfloor)f(\lfloor\frac{b}{g}\rfloor)$ 

前n个正整数的约数之和：

​	  $\sum_{i=1}^{n}\sigma_{1}(i)=\sum_{i=1}^n\sum_{j=1}^{n}[j|i]*j=\sum_{i=1}^{n}i*\sum_{j=1}^{n}[i|j]=\sum_{i=1}^{n}i\ast \lfloor\frac{n}{i}\rfloor=\sum_{i=1}^{n}\frac{\lfloor\frac{n}{i}\rfloor\ast (\lfloor\frac{n}{i}\rfloor+1)}{2}$

前n个正整数的欧拉函数之和：

​	 $\varphi(n)=n-\sum_{d|n,d<n}\varphi(d)$ 	

​	 $\phi(n)=\sum_{i=1}^{n}\varphi(i)=\sum_{i=1}^{n}(i-\sum_{d|i,d<i}\varphi(d))=\frac{n*(n+1)}{2}-\sum_{i=2}^{n}\sum_{d|i,d<i}\varphi(d)$

​	   	  $=\frac{n*(n+1)}{2}-\sum_{i=2}^{n}\sum_{d=1}^{\lfloor\frac{n}{i}\rfloor}\varphi(d)=\frac{n*(n+1)}{2}-\sum_{i=2}^{n}\phi(\lfloor\frac{n}{i}\rfloor)$

   $\frac{n*(n+1)}{2}=\sum_{i}^{n}i=\sum_{i=1}^{n}\sum_{d|i}\varphi(d)=\sum_{\frac{i}{d}=1}^{n}\sum_{d=1}^{\lfloor\frac{n}{\frac{i}{d}}\rfloor}\varphi(d)=\sum_{i=1}^{n}\phi(\lfloor\frac{n}{i}\rfloor)$ 

前n个正整数因数的欧拉函数之和：

​	 $\sum_{i=1}^n\sum_{d|i}\varphi(d)=\sum_{d=1}^n\varphi(d)\lfloor\frac{n}{d}\rfloor$ 

前n个k次方正整数的欧拉函数之和：

​	  $\sum_{i=1}^n\varphi(i^k)=\sum_{i=1}^ni^{k-1}\varphi(i)$	与$ID^{k-1}$卷积然后杜教筛即可

前n个正整数的欧拉函数k次方之和：

​	用min_25筛

前n个正整数的莫比乌斯函数之和（梅滕斯函数）：

 $1=\sum_{i=1}^{n}[i=1]=\sum_{i=1}^{n}\sum_{d|i}\mu(d)=\sum_{i=1}^{n}\sum_{d=1}^{\lfloor\frac{n}{i}\rfloor}\mu(d)=\sum_{i=1}^{n}M(\lfloor\frac{n}{i}\rfloor)$

 $M(n)=1-\sum_{i=2}^{n}M(\lfloor\frac{n}{i}\rfloor)$

 $\mu^2(d)=\sum_{k^2|d}\mu(k)$ :

证明：当d没有平方因子时 $\sum_{k^2|d}\mu(k)=1，\mu^2(d)=1$

​	   当d有平方因子x^2时 $\sum_{k^2|d}\mu(k)=\sum_{k^2|x^2}\mu(k)=\sum_{k|x}\mu(k)=0,\mu^2(d)=0$

前n个正整数的莫比乌斯函数平方之和：

​	 $S(n)=\sum_{i=1}^n\mu^2(i)=\sum_{i=1}^n\sum_{d^2|i}\mu(d)=\sum_{i=1}^{n}\sum_{d=1}^{\sqrt{\lfloor\frac{n}{i}\rfloor}}\mu(d)=\sum_{i=1}^{\sqrt{n}}\mu(i)\lfloor \frac{n}{i^2} \rfloor$

前n个正整数的因数的莫比乌斯函数平方之和：

​	 $S(n)=\sum_{i=1}^{n}\sum_{d|i}\mu^2(d)=\sum_{i=1}^{n}\sum_{d|i}\sum_{k^2|d}\mu(k)=\sum_{i=1}^{n}\mu(i)\sum_{j=1}^{\frac{n}{i^2}}\lfloor\frac{n}{i^2j}\rfloor$

​	可发现i的取值范围可以缩小到$\sqrt{n}$ ，令$f(n)=\sum_{i=1}^{n}\lfloor\frac{n}{i}\rfloor$

​	则 $S(n)=\sum_{i=1}^{\sqrt{n}}\mu(i)f(\lfloor\frac{n}{i^2}\rfloor)$

小于等于n的两两数最小公倍数之和：

​	 $ans=\sum_{d=1}^{n}d\sum_{i=1}^{\lfloor\frac{n}{d}\rfloor}i^2\varphi(i)$

​	第二个求和式卷积即可求

小于等于n的两两数最大公约数之和：

​	 $ans=\sum_{i=1}^n\lfloor\frac{n}{i}\rfloor\ast \lfloor\frac{n}{i}\rfloor\ast \varphi(i)$

求lcm(a,b)+lcm(a+1,b)+...+lcm(b,b):

​	 $ans=\frac{b}{2}\sum_{T|b}(\frac{b}{T}+\lceil\frac{a}{T}\rceil)(\frac{b}{T}-\lceil\frac{a}{T}\rceil+1)\sum_{d|T}\mu(d)d$

​	最右边和式用积性函数性质算即可

求最小公倍数在某一区间的(x<=y)二元组数量：

​	区间[l,r]=[1,r]-[1,l-1]

​	 $G(n)=\sum_{i=1}^{n}\sum_{y=1}^{n}[\frac{xy}{gcd(x,y)}<=n]=\sum_{k=1}^{\sqrt{n}}\mu(k)H(\lfloor\frac{n}{k^2}\rfloor)$

​	 $H(n)=\sum_{a=1}^n\sum_{b=1}^{\lfloor\frac{n}{a}\rfloor}\sum_{c=1}^{\lfloor\frac{n}{ab}\rfloor}1$

​	 H(n)枚举前两项(a<=b)用组合数求即可

求在1到n区间内互质对的个数

​	 $R(n)=2\phi(n)-1=-1+\sum_{d=1}^n\mu(d)\lfloor \frac{n}{d}\rfloor \lfloor1+\frac{n}{d}\rfloor=\sum_{d=1}^n\lfloor\frac{n}{d}\rfloor^2\mu(d)$ 

 $\sum_{d|n}g(d)\varphi(\frac{n}{d})=1$ 

​	 $g(n)$是$(k+1-kp)$对于恰好整除n的所有素数幂$p^k$的乘积

 $\sum_{m,n>0}\frac{[gcd(m,n)==1]}{m^2n^2}=\frac{5}{2}$ 

### FFT （快速傅里叶变换）

```c++
#define L(x) (1 << (x))
const double PI = acos(-1.0);
const int N = 2e5+5;
double ax[N],ay[N],bx[N],by[N];
int revv(int x, int bits)
{
    int ret=0;
    for(int i=0;i<bits;i++){ret<<=1;ret|=x&1;x>>=1;}
    return ret;
}
void fft(double * a, double * b, int n, bool rev)
{
    int bits=0;
    while((1<<bits)<n)++bits;
    for(int i=0;i<n;i++){
        int j=revv(i,bits);
        if(i<j)swap(a[i],a[j]),swap(b[i],b[j]);
    }
    for(int len=2;len<=n;len<<=1){
        int half=len>>1;
        double wmx=cos(2*PI/len),wmy=sin(2*PI/len);
        if(rev)wmy=-wmy;
        for(int i=0;i<n;i+=len){
            double wx=1,wy=0;
            for(int j=0;j<half;j++){
                double cx=a[i+j],cy=b[i+j];
                double dx=a[i+j+half],dy=b[i+j+half];
                double ex=dx*wx-dy*wy,ey=dx*wy+dy*wx;
                a[i+j]=cx+ex,b[i+j]=cy+ey;
                a[i+j+half]=cx-ex,b[i+j+half]=cy-ey;
                double wnx=wx*wmx-wy*wmy,wny=wx*wmy+wy*wmx;
                wx=wnx,wy=wny;
            }
        }
    }
    if(rev){for(int i=0;i<n;i++) a[i]/=n,b[i]/=n;}
}
int solve(int a[],int na,int b[],int nb,int ans[]) //两个数组求卷积,有时ans数组要开成long long
{
    int len=max(na,nb),ln;
    for(ln=0;L(ln)<len;++ln);
    len=L(++ln);
    for(int i=0;i<len;++i){
        if(i>=na)ax[i]=0,ay[i]=0;
        else ax[i]=a[i],ay[i]=0;
    }
    fft(ax,ay,len,0);
    for(int i=0;i<len;++i){
        if(i>=nb) bx[i]=0,by[i]=0;
        else bx[i]=b[i],by[i]=0;
    }
    fft(bx,by,len,0);
    for(int i=0;i<len;++i){
        double cx=ax[i]*bx[i]-ay[i]*by[i];
        double cy=ax[i]*by[i]+ay[i]*bx[i];
        ax[i]=cx,ay[i]=cy;
    }
    fft(ax,ay,len,1);
    for(int i=0;i<len;++i) ans[i]=(int)(ax[i]+0.5);
    return len;
}
```

### NTT （快速数论变换）

```C++
//选好素数
const int M = 22;
ll G=3,P=998244353,wn[M];//P=7*2^26+1，M=k-1
ll modexp(ll a,ll b,ll p){
    ll ans=1LL;a%=p;
    while(b){if(b&1)ans=ans*a%p;b>>=1;a=a*a%p;}
    return ans;
}
void getwn(){for(int i=0;i<M;i++) wn[i]=modexp(G,(P-1)/(1<<i),P);}//!!!记得用
void NTT(ll x[],int n,int rev) {
    int i,j,k,ds;ll w,u,v;
    for(i=1,j=n>>1,k=n>>1;i<n-1;i++,k=n>>1){
        if(i<j)swap(x[i],x[j]);
        while(j>=k){j-=k;k>>=1;}
        if(j<k)j+=k;
    }
    for(i=2,ds=1;i<=n;i<<=1,ds++)
        for(j=0;j<n;j+=i){
            w=1;
            for(k=j;k<j+i/2;k++){
                u=x[k]%P;v=w*x[k+i/2]%P;
                x[k]=(u+v)%P;
                x[k+i/2]=(u-v+P)%P;
                w=w*wn[ds]%P;
            }
        }
    if(rev==-1){
        for(i=1;i<n/2;i++) swap(x[i],x[n-i]);
        w=modexp(n,P-2,P);
        for(i=0;i<n;i++) x[i]=x[i]*w%P;
    }
}
int solve(ll a[],int lena,ll b[],int lenb) {//结果在a数组
    int n=1;
    while (n<lena+lenb) n<<=1;
    for(int i=lena;i<n;i++)a[i]=0;
    for(int i=lenb;i<n;i++)b[i]=0;
    NTT(a,n,1);NTT(b,n,1);
    for (int i=0;i<n;i++) a[i]=a[i]*b[i]%P;
    NTT(a,n,-1);
    return n;
} 
```

### 三模数NTT所需函数

```
inline ll mul(ll a,ll b,ll mod){
    a%=mod;b%=mod;
    return ((a*b-(ll)((ll)((long double)a/mod*b+1e-3)*mod))%mod+mod)%mod;
}
ll modexp(ll a,ll b,ll p)
{
    ll ans=1LL;a%=p;
    while(b){if(b&1)ans=ans*a%p;b>>=1;a=a*a%p;}
    return ans;
}
ll M[]={998244353,1004535809,469762049};
ll _M=(ll)M[0]*M[1];
ll m1=M[0],m2=M[1],m3=M[2];
ll inv1=modexp(m1%m2,m2-2,m2),inv2=modexp(m2%m1,m1-2,m1),inv12=modexp(_M%m3,m3-2,m3);
inline int CRT(int a1,int a2,int a3){//注意顺序
    ll A=(mul((ll)a1*m2%_M,inv2,_M)+mul((ll)a2*m1%_M,inv1,_M))%_M;
    ll k=((ll)a3+m3-A%m3)*inv12%m3;
    return (k*(_M%P)+A)%P;
}
```



### NTT 素数表

如果模数P 任意，取的模数必须超过n(P-1)^2 ，可以取多个模数（乘积>n(P-1)^2）做NTT。再用中国剩余定理合并,每次NTT转化为三个NTT再合并即可

```

r⋅2^k+1	r	k	g
3	1	1	2
5	1	2	2
17	1	4	3
97	3	5	5
193	3	6	5
257	1	8	3
7681	15	9	17
12289	3	12	11
40961	5	13	3
65537	1	16	3
786433	3	18	10
5767169	11	19	3
7340033	7	20	3
23068673	11	21	3
104857601	25	22	3
167772161	5	25	3
469762049	7	26	3
998244353	119	23	3
1004535809	479	21	3
2013265921	15	27	31
2281701377	17	27	3
3221225473	3	30	5
75161927681	35	31	3
77309411329	9	33	7
206158430209	3	36	22
2061584302081	15	37	7
2748779069441	5	39	3
6597069766657	3	41	5
39582418599937	9	42	5
79164837199873	9	43	5
263882790666241	15	44	7
1231453023109121	35	45	3
1337006139375617	19	46	3
3799912185593857	27	47	5
4222124650659841	15	48	19
7881299347898369	7	50	6
31525197391593473	7	52	3
180143985094819841	5	55	6
1945555039024054273	27	56	5
4179340454199820289	29	57	3
```

### 多项式开方、求逆、积分、求exp、求ln、求幂、除法、取模

多项式求逆： $B(x)=2G(x)-A(x)G^2(x) (mod x^n)$

多项式开方： $B(x)=\frac{A(x)+G^2(x)}{2G(x)} (mod x^n)$

​		 $G(x)=(1+ln(1+\frac{1}{exp(\lmoustache \frac{1}{\sqrt{F(x)}})}))^k$ 

多项式除法：$F(x)=Q(x)\times G(x)+R(x)$ ,求Q(x)和R(x)

```
//给定F(x) 求G'(x)
# include <bits/stdc++.h>
# define RG register
# define IL inline
# define Fill(a, b) memset(a, b, sizeof(a))
using namespace std;
typedef long long ll;

IL int Input(){
    RG int x = 0, z = 1; RG char c = getchar();
    for(; c < '0' || c > '9'; c = getchar()) z = c == '-' ? -1 : 1;
    for(; c >= '0' && c <= '9'; c = getchar()) x = (x << 1) + (x << 3) + (c ^ 48);
    return x * z;
}

const int maxn(8e5 + 5);
const int mod(998244353);
const int phi(998244352);
const int inv2(499122177);
const int g(3);

int a[maxn], b[maxn], c[maxn], d[maxn],e[maxn], r[maxn];

IL int Pow(RG ll x, RG ll y){
    RG ll ret = 1;x%=mod;
    for(; y; y >>= 1, x = x * x % mod)
        if(y & 1) ret = ret * x % mod;
    return ret;
}
IL void NTT(RG int *p, RG int m, RG int opt){
    RG int n = 1, l = 0;
    for(; n < m; n <<= 1) ++l;
    for(RG int i = 0; i < n; ++i) r[i] = (r[i >> 1] >> 1) | ((i & 1) << (l - 1));
    for(RG int i = 0; i < n; ++i) if(r[i] < i) swap(p[i], p[r[i]]);
    for(RG int i = 1; i < n; i <<= 1){
        RG int t = i << 1, wn = Pow(g, phi / t);
        if(opt == -1) wn = Pow(wn, mod - 2);
        for(RG int j = 0; j < n; j += t)
            for(RG int k = 0, w = 1; k < i; ++k, w = 1LL * w * wn % mod){
                RG int x = p[k + j], y = 1LL * w * p[k + j + i] % mod;
                p[k + j] = (x + y) % mod, p[k + j + i] = (x - y + mod) % mod;
            }
    }
    if(opt == -1){
        RG int inv = Pow(n, mod - 2);
        for(RG int i = 0; i < n; ++i) p[i] = 1LL * p[i] * inv % mod;
    }
}
IL void Inv(RG int *p, RG int *q, RG int len){//多项式求逆,p为A(x)，q为G(x)
    if(len == 1){
        q[0] = Pow(p[0], mod - 2);
        return;
    }
    Inv(p, q, len >> 1);
    for(RG int i = 0; i < len; ++i) a[i] = p[i], b[i] = q[i];
    RG int tmp = len << 1;
    NTT(a, tmp, 1), NTT(b, tmp, 1);
    for(RG int i = 0; i < tmp; ++i) a[i] = 1LL * a[i] * b[i] % mod * b[i] % mod;
    NTT(a, tmp, -1);
    for(RG int i = 0; i < len; ++i) q[i] = ((2 * q[i] - a[i]) % mod + mod) % mod;
    for(RG int i = 0; i < tmp; ++i) a[i] = b[i] = 0;
}
IL void Sqrt(RG int *p, RG int *q, RG int len){//多项式开方,p为A(x),q为G(x)
    if(len == 1){
        q[0] = sqrt(p[0]); //???
        return;
    }
    Sqrt(p, q, len >> 1), Inv(q, c, len);   
    RG int tmp = len << 1;
    for(RG int i = 0; i < len; ++i) a[i] = p[i];
    NTT(a, tmp, 1), NTT(c, tmp, 1);
    for(RG int i = 0; i < tmp; ++i) a[i] = 1LL * a[i] * c[i] % mod;
    NTT(a, tmp, -1);
    for(RG int i = 0; i < len; ++i) q[i] = 1LL * (q[i] + a[i]) % mod * inv2 % mod;
    for(RG int i = 0; i < tmp; ++i) a[i] = c[i] = 0;
}
IL void ICalc(RG int *p, RG int *q, RG int len){//多项式求导
    q[len - 1] = 0;
    for(RG int i = 1; i < len; ++i) q[i - 1] = 1LL * p[i] * i % mod;
}
IL void Calc(RG int *p, RG int *q, RG int len){//多项式积分
    q[0] = 0;
    for(RG int i = 1; i < len; ++i) q[i] = 1LL * Pow(i, mod - 2) * p[i - 1] % mod;
}
IL void Ln(RG int *p, RG int *q, RG int len){//多项式求ln
    Inv(p, c, len), ICalc(p, a, len);
    RG int tmp = len << 1;
    NTT(c, tmp, 1), NTT(a, tmp, 1);
    for(RG int i = 0; i < tmp; ++i) c[i] = 1LL * c[i] * a[i] % mod;
    NTT(c, tmp, -1), Calc(c, q, len);
    for(RG int i = 0; i < tmp; ++i) a[i] = c[i] = 0;
}
IL void Exp(RG int *p, RG int *q, RG int len){//多项式求exp
    if(len == 1){
        q[0] = 1;
        return;
    }
    Exp(p, q, len >> 1), Ln(q, b, len);
    for(RG int i = 0; i < len; ++i) b[i] = (mod - b[i] + p[i]) % mod, c[i] = q[i];
    b[0] = (b[0] + 1) % mod;
    RG int tmp = len << 1;
    NTT(b, tmp, 1), NTT(c, tmp, 1);
    for(RG int i = 0; i < tmp; ++i) b[i] = 1LL * b[i] * c[i] % mod;
    NTT(b, tmp, -1);
    for(RG int i = 0; i < len; ++i) q[i] = b[i];
    for(RG int i = 0; i < tmp; ++i) b[i] = c[i] = 0;
}
IL void CalcPow(RG int *p, RG int *q, RG int len, RG int y){//多项式求幂
    Ln(p, d, len);
    for(RG int i = 0; i < len; ++i) d[i] = 1LL * d[i] * y % mod;
    Exp(d, q, len);
    for(RG int i = 0; i < len; ++i) d[i] = 0;
}
IL void Div(RG int *p,RG int len1, RG int *q,RG int len2,RG int *R){//多项式除法及取模,q:Q,R:R
    reverse(p,p+len1);reverse(q,q+len2);
    int len;
    for(len=1;len<=len1-len2+1;len<<=1);
    Inv(q,d,len);
    for(int i=0;i<len1;i++)a[i]=p[i];
    for(int i=len1-len2+1;i<len;i++)d[i]=0;
    RG int tmp;
    for(tmp=1;tmp<=len1+len1-len2+1;tmp<<=1);
    NTT(a,tmp,1);NTT(d,tmp,1);
    for(int i=0;i<tmp;i++)d[i]=1LL*a[i]*d[i]%mod;
    NTT(d,tmp,-1);

    for(int i=0;i<tmp;i++)a[i]=0;
    reverse(d,d+len1-len2+1);
    for(int i=len1-len2+1;i<tmp;i++)d[i]=0;
    for(int i=0;i<=len1-len2;i++)e[i]=d[i];
    reverse(p,p+len1);reverse(q,q+len2);    
    for(int i=0;i<len1;i++)a[i]=p[i];
    for(int i=0;i<len2;i++)b[i]=q[i];

    for(tmp=1;tmp<=len1+1;tmp<<=1);
    NTT(b,tmp,1);NTT(e,tmp,1);
    for(int i=0;i<tmp;i++)b[i]=1LL*b[i]*e[i]%mod;
    NTT(b,tmp,-1);
    for(int i=0;i<len2-1;i++)R[i]=(a[i]-b[i]+mod)%mod;
    for(int i=0;i<tmp;i++)b[i]=e[i]=a[i]=0;
    for(int i=0;i<=len1-len2;i++)q[i]=d[i],d[i]=0;
}

int f[maxn], h[maxn], n, k, len;

IL void Record(){
    for(RG int i = 0; i < len; ++i) f[i] = h[i], h[i] = 0;
}
int main(){
    freopen("polynomial.in", "r", stdin);
    freopen("polynomial.out", "w", stdout);
    n = Input() - 1, k = Input();
    for(RG int i = 0; i <= n; ++i) f[i] = Input();
    for(len = 1; len <= n; len <<= 1);
    Sqrt(f, h, len), Record();
    Inv(f, h, len), Record();
    Calc(f, h, n + 1), Record();
    Exp(f, h, len), Record();
    Inv(f, h, len), Record();
    f[0] = (f[0] + 1) % mod;
    Ln(f, h, len), Record();
    f[0] = (f[0] + 1) % mod;
    CalcPow(f, h, len, k), Record();
    ICalc(f, h, n + 1);
    for(RG int i = 0; i <= n; ++i) printf("%d ", h[i]);
    return 0;
}
```

### 多项式除法及取模（待补）



### BSGS算法（求最小的x满足 a^x = b (mod n) n为质数）

```
const int MOD = 76543;
int hs[MOD],head[MOD],Next[MOD],id[MOD],top;
void insert(int x,int y)
{
    int k = x%MOD;
    hs[top] = x, id[top] = y, Next[top] = head[k], head[k] = top++;
}
int find(int x)
{
    int k = x%MOD;
    for(int i = head[k]; i != -1; i = Next[i])
        if(hs[i] == x)
            return id[i];
    return -1;
}
int BSGS(int a,int b,int n)//a^x = b(mod n)
{
	a%=n;b%=n;
    memset(head,-1,sizeof(head));
    top = 1;
    if(b == 1)return 0;
    int m = sqrt(n*1.0), j;
    long long x = 1, p = 1;
    for(int i = 0; i < m; ++i, p = p*a%n)insert(p*b%n,i);
    for(long long i = m; ;i += m)
    {
        if( (j = find(x = x*p%n)) != -1 )return i-j;
        if(i > n)break;
    }
    return -1;
}
```

### ex_BSGS算法 （n不为质数）

```c++
const int N = 1e5+3;//一定为素数
ll point[N*2],Next[N*2],val[N*2],pla[N*2],tot;
void add(ll x,ll y){
    ll xx=x%N;
    Next[++tot]=point[xx];
    val[tot]=x;
    pla[tot]=y;
    point[xx]=tot;
}
ll find(ll x){
    ll i;
    ll xx=x%N;
    for (i=point[xx];i;i=Next[i]){
        if (val[i]==x)return pla[i];
    }
    return -1;
}
ll gcd(ll a,ll b){
    return b==0?a:gcd(b,a%b);
}
ll qpow(ll a,ll b,ll mod){
    ll ans;
    for (ans=1;b;a=a*a%mod,b>>=1){
        if (b&1)ans=ans*a%mod;
    }
    return ans;
}
ll ex_BSGS(ll a,ll b,ll p){// a^x = b (mod p) 
    a%=p;b%=p;
    ll i;
    if (b==1)return 0;
    ll t=gcd(a,p),d=1,k=0;
    while (t!=1){
        if (b%t)return -1;
        b/=t;
        p/=t;
        d=d*(a/t)%p;
        k++;
        if (b==d)return k;
        t=gcd(a,p);
    }
    memset (point,0,sizeof(point));
    memset (Next,0,sizeof(Next));
    tot=0;
    ll m=ceil(sqrt(p));
    ll am=qpow(a,m,p);
    ll mul=b;
    add(mul,0);
    for (i=1;i<=m;i++){
        mul=mul*a%p;
        add(mul,i);
    }
    for (i=1;i<=m+1;i++){
        d=d*am%p;
        ll place=find(d);
        if (place!=-1)return i*m-place+k;
    }
    return -1;
}
```






