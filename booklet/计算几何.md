## 计算几何

```cpp
#include <bits/stdc++.h>
using namespace std;
const double eps=1e-8;
#define ll long long
#define sz(x) (int)(x).size()
const double PI=acos(-1.0);
ll gcd(ll x,ll y){return y==0?x:gcd(y,x%y);}
int sgn(double x){if(abs(x)<eps)return 0;return x<0?-1:1;}
struct point{
    double x,y;

    point(double _x=0,double _y=0){
        x=_x;
        y=_y;
    }
    double norm(){return sqrt(x*x+y*y);}
    point operator - (const point & b)const {return {x-b.x,y-b.y};}
    point operator + (const point & b)const {return {x+b.x,y+b.y};}
    point operator / (const double & b)const {return {x/b,y/b};}
    point operator * (const double & b)const {return {x*b,y*b};}
    double operator * (const point & b)const {return x*b.y-b.x*y;}//叉乘
    bool operator < (const point & b)const {return sgn(x-b.x)?x<b.x:sgn(y-b.y)?y<b.y:0;}
    bool operator == (const point & b)const {return !sgn(x-b.x) && !sgn(y-b.y);}
};
struct line{
    point a,b;
    double angle;
    line(point _a=0,point _b=0){
        a=_a;b=_b;
        angle=atan2(b.y-a.y,b.x-a.x);
    }
};
double dot( point a , point b ) { return a.x * b.x + a.y * b.y ; }
double det( point a , point b ) { return a.x * b.y - a.y * b.x ; }
double dist( point a , point b ) { return ( a - b ).norm() ; }
double area(const point& a,const point& b,const point& c){return abs((b-a)*(c-a))/2;}
pair<bool,point> line_intersection(const line & a,const line & b){//线段交
    if(!sgn((a.a-a.b)*(b.a-b.b)))return {0,{}};
    if(sgn((b.a-a.a)*(b.a-b.b))*sgn((b.a-a.b)*(b.a-b.b))>0)return {0,{}};
    if(sgn((a.a-b.a)*(a.a-a.b))*sgn((a.a-b.b)*(a.a-a.b))>0)return {0,{}};
    double sa=area(a.a,b.a,a.b);
    double sb=area(a.b,a.a,b.b);
    return {1,b.a+(b.b-b.a)*sa/(sa+sb)};
}
vector<point> graham(vector<point> p){
    sort(p.begin(),p.end(),[](const point & a,const point & b){return a.x==b.x?a.y<b.y:a.x<b.x;});
    p.erase(unique(p.begin(),p.end()),p.end());
    int n=sz(p),m=0,k,i;
    vector<point> res(n+1); 
    for(i=0;i<n;i++){
        while(m>1&&(res[m-1]-res[m-2])*(p[i]-res[m-2])<=0) m--; 
        res[m++]=p[i]; 
    }
    k=m;
    for(i=n-2;i>=0;i--){
        while(m>k&&(res[m-1]-res[m-2])*(p[i]-res[m-2])<=0) m--; 
        res[m++]=p[i]; 
    }
    if(n>1) m--;
    res.resize(m);
    return res;
}

int main(){
    
    return 0;
}

```

###多边形面积

```
double getArea(point *p,int n)//多边形面积
{
    if (n< 3) return 0;
    double area = 0;
    for (int i = 1; i < n-1; i++)
        area += (p[i]-p[0])*(p[i+1]-p[0]);//利用p数组求面积
    return fabs(area/2.0);
}
```

### 凸包内最大三角形面积

```
double rotating_calipers(point *p,int n)//旋转卡壳求凸包内三角新最大面积
{
    double ans = 0.0;
    for(int i = 0;i < n;i++)
    {
        int j = (i+1)%n;
        int k = (j+1)%n;
        while(j != i && k != i)
        {
            ans = max(ans,abs((p[j]-p[i])*(p[k]-p[i])) );
            while( ( (p[i]-p[j])*(p[(k+1)%n]-p[k]) ) < 0 )
                k = (k+1)%n;
            j = (j+1)%n;
        }
    }
    return ans/2.0;
}
```

### 半平面交

```
point getIntersect(line& l1, line& l2){//求直线交点
    double A1 = l1.b.y - l1.a.y;
    double B1 = l1.a.x - l1.b.x;
    double C1 = (l1.b.x - l1.a.x) * l1.a.y - (l1.b.y - l1.a.y) * l1.a.x;
    double A2 = l2.b.y - l2.a.y;
    double B2 = l2.a.x - l2.b.x;
    double C2 = (l2.b.x - l2.a.x) * l2.a.y - (l2.b.y - l2.a.y) * l2.a.x;
    point p;
    p.x = (C2 * B1 - C1 * B2) / (A1 * B2 - A2 * B1);
    p.y = (C1 * A2 - C2 * A1) / (A1 * B2 - A2 * B1);
    return p;
}
bool cmp(const line& l1, const line& l2)
{
    int d = sgn(l1.angle-l2.angle);
    if (!d) return sgn((l2.a-l1.a)*(l2.b-l1.a)) < 0;
    return d < 0;
}
bool judge(line& l0, line& l1, line& l2)
{
    point p=getIntersect(l1,l2);
    return sgn((l0.a-p)*(l0.b-p)) > 0;
    //与上面的注释处的大于小于符号相反，大于0，是p在向量l0.a->l0.b的左边，小于0是在右边，当p不在半平面l0内时，返回true
}
void HalfPlaneIntersect(point *p,int n,point *p1,int& n1)//半平面交,p1放答案
{
    p[n]=p[0];
    vector<line>l;
    for(int i=0;i<n;i++) l.push_back(line(p[i],p[i+1]));
    sort(l.begin(),l.end(), cmp); //极角排序
    int i,j;
    for (i = 0, j = 0; i < n; i++)
        if (sgn(l[i].angle-l[j].angle) > 0)
            l[++j] = l[i];//排除极角相同（从了l[1]开始比较）
    n = j + 1;//个数
    vector<int>dq(n*2);
    dq[0] = 0;//双端队列
    dq[1] = 1;//开始入队列两条直线
    int top=1,bot=0;

    for (int i = 2; i < n; i++)
    {
        while (top > bot && judge(l[i], l[dq[top]], l[dq[top-1]])) top--;
        while (top > bot && judge(l[i], l[dq[bot]], l[dq[bot+1]])) bot++;
        dq[++top] = i;
    }
    while (top > bot && judge(l[dq[bot]], l[dq[top]], l[dq[top-1]])) top--;
    while (top > bot && judge(l[dq[top]], l[dq[bot]], l[dq[bot+1]])) bot++;
    dq[++top] = dq[bot];n1=0;
    for (int i = bot; i < top; i++){
        p1[n1++]=getIntersect(l[dq[i+1]], l[dq[i]]);//更新重复利用p数组
    }
}
```



###向量直线平移

```
void move(point &a,point &b,double r){//向量直线a->b向右平移r距离
    point tmp=b-a;
    tmp=point(tmp.y,-tmp.x);
    tmp=tmp/sqrt(dot(tmp,tmp));
    tmp=tmp*r;
    a=a+tmp;b=b+tmp;
}
```



### 点到线段，线段到线段

```
double PointTOline( point const&a,point const&b,point const&p){
    double ap_ab = (b.x - a.x)*(p.x - a.x)+(b.y - a.y)*(p.y - a.y);//cross( a , p , b );
    if ( ap_ab <= 0 )
        return sqrt( (p.x-a.x)*(p.x-a.x) + (p.y-a.y)*(p.y-a.y) );
 
    double d2 = ( b.x - a.x ) * ( b.x - a.x ) + ( b.y-a.y ) * ( b.y-a.y ) ;
    if ( ap_ab >= d2 ) return sqrt( (p.x - b.x )*( p.x - b.x ) + ( p.y - b.y )*( p.y - b.y));
    double r = ap_ab / d2;
    double px = a.x + ( b.x - a.x ) *r;
    double py = a.y + ( b.y - a.y ) *r;
    return sqrt( (p.x - px)*(p.x - px) + (p.y - py)*(p.y - py) );
}
double LineToline(line const& A,line const& B)
{
    if(line_intersection(A,B).fi)return 0.0;
    double ans1=min(PointTOline(A.a,A.b,B.a),PointTOline(A.a,A.b,B.b));
    double ans2=min(PointTOline(B.a,B.b,A.a),PointTOline(B.a,B.b,A.b));
    return min(ans1,ans2);
}
```

### 点是否在简单多边形内

```
bool isOnline( point const&a,point const&b, point const&po ){//点是否在线段上
    return po.x >= min( a.x , b.x ) &&
           po.x <= max( a.x , b.x ) &&
           po.y >= min( a.y , b.y ) &&
           po.y <= max( a.y , b.y ) &&
           ( po.x - a.x ) * ( b.y - a.y ) == ( po.y - a.y ) * ( b.x - a.x );
}
bool isInSimple( point * p ,int n , point const&po ){//点是否在简单多边形内
 
    p[n] = p[0];
    bool flag = 0;
    int tmp;
    for ( int i = 0; i < n;++i ){
        if ( isOnline( p[i] , p[i+1] , po ) ) return true;
        if ( p[i].y == p[i+1].y ) continue;
        p[i].y < p[i+1].y ? tmp = i+1 : tmp = i ;
        if ( po.y == p[tmp].y && po.x < p[tmp].x ) flag ^= 1;
        p[i].y > p[i+1].y ? tmp = i+1 : tmp = i ;
        if ( po.y == p[tmp].y && po.x < p[tmp].x ) continue ;
 
        if ( po.x < max( p[i].x , p[i+1].x ) &&
             po.y > min( p[i].y , p[i+1].y ) &&
             po.y < max( p[i].y , p[i+1].y ) ) flag ^= 1;
    }
    return flag;
}
```

### 点到凸多边形，凸多边形到凸多边形

```
double pointTopolygon(point * p,int n,point const& po)
{
    double ans=1e18;
    if(isInSimple(p,n,po))return 0.0;
    p[n]=p[0];
    for(int i=1;i<=n;i++) ans=min(ans,PointTOline(p[i-1],p[i],po));
    return ans;
}
double polygonTopolygon(point * p1,int n1,point * p2,int n2)
{
    double ans=1e18;
    for(int i=0;i<n1;i++)ans=min(ans,pointTopolygon(p2,n2,p1[i]));
    for(int i=0;i<n2;i++)ans=min(ans,pointTopolygon(p1,n1,p2[i]));
    return ans;
}
```



### 点到圆圆到圆

```
double pointTocircle(pair<point,double> &c,point &po)
{
    return max(0.0,dist(po,c.fi)-c.se);
}
double CircleTocircle(pair<point,double> a,pair<point,double> b)
{
    return max(0.0,dist(a.fi,b.fi)-a.se-b.se);
}
```

### 线段-圆-凸多边形

```
double lineTocircle(line const & l,pair<point,double> const & c)
{
	return max(0.0,PointTOline(l.a,l.b,c.fi)-c.se);
}
double lineTopolygon(line const & l,point *p,int n)
{
	int flag=0;
	if(isInSimple(p,n,l.a)||isInSimple(p,n,l.b))flag=1;
	p[n]=p[0];
	for(int i=1;i<=n;i++) if(line_intersection(l,{p[i],p[i-1]}).fi)flag=1;
	if(flag)return 0.0;
	double ans=INF;
	for(int i=1;i<=n;i++) ans=min(ans,PointTOline(p[i-1],p[i],l.a));
	for(int i=1;i<=n;i++) ans=min(ans,PointTOline(p[i-1],p[i],l.b));
	for(int i=0;i<n;i++) ans=min(ans,PointTOline(l.a,l.b,p[i]));
	return ans;
}
double CircleTopolygon(pair<point,double> const & c,point *p,int n)
{
	return max(0.0,pointTopolygon(p,n,c.fi)-c.se);
}
```



### 费马点

```c++
//三角形内一点到三点距离之和最短
#include <bits/stdc++.h>

using namespace std;
#define pb push_back
#define fi first
#define se second

struct Vec
{
    double x,y;
    Vec(double xx=0,double yy=0)
    {
        x=xx;
        y=yy;
    }
};
 
struct Point
{
    double x,y;
    Point(double xx=0,double yy=0)
    {
        x=xx;
        y=yy;
    }
};
 
double ddot(Vec A,Vec B)
{
    return A.x*B.x+A.y*B.y;
}
double getlen(Vec A)
{
    return sqrt(A.x*A.x+A.y*A.y);
}
 
double getlen(Point A,Point B)
{
    return sqrt((A.x-B.x)*(A.x-B.x)+(A.y-B.y)*(A.y-B.y));
}
 
bool ask(double xa,double ya,double xb,double yb,double xc,double yc)//判断费马点是否在顶点上
{
    Vec ab(xb-xa,yb-ya),ac(xc-xa,yc-ya);
    if (ddot(ab,ac)/getlen(ab)/getlen(ac) < -0.5)
    {
        return true;
    }
    return false;
}
 
inline void swap(double &a,double &b)
{
    double t;
    t=a;
    a=b;
    b=t;
}
 
 
Point getAnotherPoint(Point A,Point B,Point C)
{
    Point r,C1,C2;
    Vec AB(B.x-A.x,B.y-A.y);
    double len,len2;
    double sqrt3=sqrt(3.0);
    Vec AB2,crossAB,crossAB2;
 
    AB2.x=AB.x/2; AB2.y=AB.y/2;
    crossAB.x=AB2.y; crossAB.y=-AB2.x;
    crossAB2.x=-AB2.y; crossAB2.y=AB2.x;
 
    len=getlen(AB2);
    
    crossAB.x*=sqrt3; crossAB.y*=sqrt3;
    crossAB2.x*=sqrt3; crossAB2.y*=sqrt3;
 
    C1.x=A.x+AB2.x+crossAB.x;C1.y=A.y+AB2.y+crossAB.y;
    C2.x=A.x+AB2.x+crossAB2.x;C2.y=A.y+AB2.y+crossAB2.y;
 
    if (getlen(C,C1)<getlen(C,C2))
    {
        return C2;
    }else
        return C1;
 
}
 
 
Point getCrossPoint(Point A,Point A1,Point B,Point B1)//得到费马点
{
    Point r;
    Vec AA(A1.x-A.x,A1.y-A.y),BB(B1.x-B.x,B1.y-B.y);
    double i,j,tmp,tmp2;
    double Ax=A.x,Ay=A.y,AAx=AA.x,AAy=AA.y,Bx=B.x,By=B.y,BBx=BB.x,BBy=BB.y;
 
    if (AAx==0)
    {
        j=(Ax-Bx)/BBx;
        i=(By+BBy*j-Ay)/AAx;
    }else if (BBx==0)
    {
        i=(Bx-Ax)/AAx;
    }else if (AAy==0)
    {
        j=(Ay-By)/BBy;
        i=(Bx-Ax-BBx*j)/AAx;
    }else if (BBy==0)
    {
        i=(By-Ay)/AAy;
    }
    else
    {
        tmp=AAx;
        tmp2=AAy;
        Ax*=AAy;AAx*=AAy;Bx*=AAy;BBx*=AAy;
        Ay*=tmp;AAy*=tmp;By*=tmp;BBy*=tmp;
        j=((Ax-Ay)-(Bx-By))/(BBx-BBy);
        i=(Bx+BBx*j-Ax)/AAx;
    }
 
    r.x=(Ax+AAx*i)/tmp2;
    r.y=(Ay+AAy*i)/tmp;
    return r;
}
double xa,ya,xb,yb,xc,yc;
double l(pair<double,double>a,pair<double,double>b)
{
    a.fi-=b.fi;a.se-=b.se;
    return sqrt(a.fi*a.fi+a.se*a.se);
}
double fun()
{
    double ans=0.0;
    if(ask(xa,ya,xb,yb,xc,yc)||ask(xb,yb,xa,ya,xc,yc)||ask(xc,yc,xa,ya,xb,yb)){
        vector<double>tmp;
        tmp.pb(l({xa,ya},{xb,yb}));
        tmp.pb(l({xc,yc},{xb,yb}));
        tmp.pb(l({xa,ya},{xc,yc}));
        sort(tmp.begin(),tmp.end());
        return tmp[1];
    }
    Point C1,A1,R;
    C1=getAnotherPoint(Point(xa,ya),Point(xb,yb),Point(xc,yc));
    A1=getAnotherPoint(Point(xc,yc),Point(xb,yb),Point(xa,ya));
    R=getCrossPoint(Point(xa,ya),A1,Point(xc,yc),C1);
    ans=max(max(l({R.x,R.y},{xa,ya}),l({R.x,R.y},{xb,yb})),l({R.x,R.y},{xc,yc}));
    return ans;
}
int main()
{ 
    int T;scanf("%d",&T);
    while(T--)
    {
        scanf("%lf%lf%lf%lf%lf%lf",&xa,&ya,&xb,&yb,&xc,&yc);
        printf("%.9lf\n",fun());
    }
    return 0;   
}
```

###  判断三个圆是否有公共点

```c++
#define point complex<double>
/*
real 返回实部
imag 返回虚部
abs 返回复数的模
arg 返回辐角
*/
bool inter(point a, double r_a, point b, double r_b, point c, double r_c)
{
    if(abs(c - a) <= r_a && abs(c - b) <= r_b)
        return true;
    b -= a, c -= a;
    point r = point(b.real() / abs(b), b.imag() / abs(b));
    b /= r, c /= r;
    double d = (r_a * r_a - r_b * r_b + abs(b) * abs(b)) / (2 * abs(b)),
           h = sqrt(max(r_a * r_a - d * d, 0.0));
    if(abs(h * h + (d - abs(b)) * (d - abs(b)) - r_b * r_b) > eps)
        return false;
    if(abs(point(d, h) - c) <= r_c)
        return true;
    if(abs(point(d, -h) - c) <= r_c)
        return true;
    return false;
}
bool check(point a, double r_a, point b, double r_b, point c, double r_c)
{
    if(r_a <= -eps || r_b <= -eps || r_c <= -eps)
        return false;
    r_a = max(r_a, 0.0), r_b = max(r_b, 0.0), r_c = max(r_c, 0.0);
    if(inter(a, r_a, b, r_b, c, r_c))
        return true;
    if(inter(b, r_b, c, r_c, a, r_a))
        return true;
    if(inter(c, r_c, a, r_a, b, r_b))
        return true;
    return false;
}
```

### 简单多边形与圆面积交

``` C++
int CircleInterLine( point a, point b, point o, double r, point *p )
{
    point p1 = a - o ;
    point d = b - a ;
    double A = dot( d, d ) ;
    double B = 2 * dot( d, p1 ) ;
    double C = dot( p1, p1 ) - r*r ;

    double delta = B*B - 4*A*C ;
    if ( sgn(delta) < 0 ) return 0 ;//相离
    if ( sgn(delta) == 0 ) { //相切
        double t = -B / (2*A) ; // 0 <= t <= 1说明交点在线段上
        if ( sgn( t - 1 ) <= 0 && sgn( t ) >= 0 ) {
            p[0] = a + d*t ; 
            return 1 ;
        }
    }
    if ( sgn(delta) > 0 ) { //相交
        double t1 = ( -B - sqrt(delta) ) / (2*A) ;
        double t2 = ( -B + sqrt(delta) ) / (2*A) ; //0 <= t1, t2 <= 1说明交点在线段上
        int k = 0 ;
        if ( sgn( t1 - 1 ) <= 0 && sgn( t1 ) >= 0 ) 
            p[k++] = a + d*t1 ; 
        if ( sgn( t2 - 1 ) <= 0 && sgn( t2 ) >= 0 ) 
            p[k++] = a + d*t2 ;
        return k ;
    }
    return 0;
}
double Triangle_area( point a, point b )
{
    return fabs( det( a , b ) ) / 2.0  ;
}
double Sector_area( point a, point b ,double r)
{
    double ang = atan2( a.y , a.x ) - atan2( b.y, b.x  ) ;
    while ( ang <= 0 ) ang += 2 * PI ;
    while ( ang > 2 * PI ) ang -= 2 * PI ;
    ang = min( ang, 2*PI - ang ) ;
    return r*r * ang/2 ;
}
double calc( point a , point b , double r )
{
    point pi[2] ;
    if ( sgn( a.norm() - r ) < 0 ) {
        if ( sgn( b.norm() - r ) < 0 ) {
            return Triangle_area( a, b ) ;
        }
        else {
            CircleInterLine( a, b, point(0,0), r, pi) ;
            return Sector_area( b, pi[0],r) + Triangle_area( a, pi[0] ) ;
        }
    }
    else {
        int cnt = CircleInterLine( a, b, point(0,0), r, pi ) ;
        if ( sgn( b.norm() - r ) < 0 ) {
            return Sector_area( a, pi[0],r ) + Triangle_area( b, pi[0] ) ;
        }
        else {
            if ( cnt == 2 )
                return Sector_area( a, pi[0],r ) + Sector_area( b, pi[1],r ) + Triangle_area( pi[0], pi[1] ) ;
            else
                return Sector_area( a, b ,r) ;
        }
    }
    return 0;
}
double area_CircleAndPolygon( point *p , int n , point o , double r )
{
    double res = 0 ;
    p[n] = p[0] ;
    for ( int i = 0 ; i < n ; i++ ) {
        int tmp = sgn( det( p[i] - o , p[i+1] - o ) ) ;
        if ( tmp )  
            res += tmp * calc( p[i] - o , p[i+1] - o , r ) ;
    }
    return fabs( res ) ;
}
// 简单多边形与圆面积交
//p 简单多边形(有序),n 多边形个数, o 圆心 r 半径
```

